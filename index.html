```html
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KILL STARS - FUNKTIONIERT JETZT</title>
    <style>
        /* ===================================================================== */
        /* ============================ GRUNDSTYLES ============================ */
        /* ===================================================================== */
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a3b2e;
            touch-action: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #4caf7a;
            touch-action: none;
        }
        /* ===================================================================== */
        /* ============================== LOBBY ================================ */
        /* ===================================================================== */
        #lobby {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(145deg, #1e3c2c, #0f2819);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 20;
            color: white;
            text-shadow: 4px 4px 0 #00000080;
            backdrop-filter: blur(8px);
            padding: 20px;
            overflow-y: auto;
        }
        #lobby h1 {
            font-size: min(15vw, 80px);
            margin-bottom: 10px;
            color: #ffe484;
            text-shadow: 5px 5px 0 #b45f06;
            text-align: center;
        }
        .player-info {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .player-name-input {
            background: #2a4a3a;
            border: 2px solid gold;
            border-radius: 40px;
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            width: 200px;
        }
        .player-id {
            background: #2a4a3a;
            border: 2px solid gold;
            border-radius: 40px;
            padding: 10px 20px;
            font-size: 14px;
            color: #aaa;
            cursor: pointer;
        }
        .stats-container {
            display: flex;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .stat-box {
            background: #2a4a3a;
            border: 3px solid gold;
            border-radius: 30px;
            padding: 10px 20px;
            font-size: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 5px 0 #1a2e22;
        }
        .map-selector {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .map-btn {
            background: #3d5e4a;
            border: 3px solid gold;
            border-radius: 30px;
            padding: 15px 25px;
            font-size: min(24px, 5vw);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: 0 5px 0 #1a2e22;
        }
        .map-btn.selected {
            border-color: #ffaa00;
            transform: scale(1.05);
            background: #5a7e6a;
        }
        .map-btn:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #1a2e22;
        }
        .map-desc {
            font-size: min(14px, 3vw);
            color: #ccc;
        }
        .brawler-showcase {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            width: 100%;
            max-width: 600px;
        }
        .arrow {
            font-size: min(60px, 12vw);
            background: rgba(255,215,0,0.5);
            width: min(80px, 15vw);
            height: min(80px, 15vw);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 4px solid gold;
            color: white;
            cursor: pointer;
            touch-action: manipulation;
            transition: 0.1s;
            box-shadow: 0 5px 0 #a05f00;
        }
        .arrow:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #a05f00;
        }
        .brawler-card-large {
            background: #3d5e4a;
            border-radius: 40px;
            padding: 20px;
            width: min(350px, 70vw);
            text-align: center;
            border: 6px solid gold;
            box-shadow: 0 20px 0 #1a2e22, 0 30px 30px black;
        }
        .brawler-emoji-large {
            font-size: min(120px, 25vw);
            filter: drop-shadow(5px 10px 0 #000);
        }
        .brawler-name-large {
            font-size: min(48px, 10vw);
            font-weight: bold;
            color: #ffe484;
        }
        .brawler-stats-large {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
            font-size: min(24px, 5vw);
            background: #1f2e25;
            padding: 15px;
            border-radius: 50px;
        }
        .skin-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 10px 0;
        }
        .skin-arrow {
            background: gold;
            width: min(40px, 8vw);
            height: min(40px, 8vw);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: min(30px, 6vw);
            cursor: pointer;
            border: 2px solid white;
        }
        .skin-name {
            font-size: min(20px, 4vw);
            background: #1f2e25;
            padding: 5px 20px;
            border-radius: 30px;
        }
        .shop-button {
            background: #f9b81b;
            border: 4px solid #fff;
            border-radius: 60px;
            padding: min(15px, 3vw) min(40px, 10vw);
            font-size: min(32px, 7vw);
            font-weight: bold;
            color: #3d2b1a;
            text-shadow: 2px 2px 0 #fff;
            box-shadow: 0 10px 0 #a05f00, 0 15px 15px black;
            margin: 20px 0 10px;
            cursor: pointer;
            touch-action: manipulation;
            transition: 0.07s;
        }
        .shop-button:active {
            transform: translateY(8px);
            box-shadow: 0 2px 0 #a05f00, 0 10px 10px black;
        }
        .play-button {
            background: #f9b81b;
            border: 5px solid #fff;
            border-radius: 60px;
            padding: min(20px, 4vw) min(80px, 15vw);
            font-size: min(48px, 10vw);
            font-weight: bold;
            color: #3d2b1a;
            text-shadow: 3px 3px 0 #fff;
            box-shadow: 0 15px 0 #a05f00, 0 20px 20px black;
            margin-top: 20px;
            cursor: pointer;
            touch-action: manipulation;
            transition: 0.07s;
        }
        .play-button:active {
            transform: translateY(10px);
            box-shadow: 0 5px 0 #a05f00, 0 15px 15px black;
        }
        #shopOverlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 30;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            overflow-y: auto;
            color: white;
            backdrop-filter: blur(10px);
        }
        #shopOverlay h2 {
            font-size: min(60px, 12vw);
            color: gold;
            margin: 20px 0;
        }
        .shop-coins {
            font-size: min(30px, 6vw);
            background: #2a4a3a;
            border: 2px solid gold;
            border-radius: 40px;
            padding: 10px 30px;
            margin-bottom: 20px;
        }
        .shop-brawler-section {
            width: 100%;
            max-width: 600px;
            background: #2a4a3a;
            border-radius: 40px;
            padding: 20px;
            margin-bottom: 20px;
        }
        .shop-brawler-title {
            font-size: min(30px, 6vw);
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .shop-skin-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1f2e25;
            border-radius: 30px;
            padding: 10px 20px;
            margin-bottom: 10px;
        }
        .shop-skin-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .shop-skin-emoji {
            font-size: 40px;
        }
        .shop-skin-name {
            font-size: min(20px, 4vw);
        }
        .shop-skin-price {
            background: gold;
            color: black;
            padding: 5px 15px;
            border-radius: 30px;
            font-weight: bold;
        }
        .shop-buy-btn {
            background: #4caf50;
            border: none;
            color: white;
            padding: 8px 20px;
            border-radius: 30px;
            font-size: min(18px, 3.5vw);
            font-weight: bold;
            cursor: pointer;
        }
        .close-shop {
            background: #c0392b;
            border: 3px solid white;
            border-radius: 50px;
            padding: 15px 50px;
            font-size: 30px;
            margin: 30px;
            cursor: pointer;
        }
        /* ===================================================================== */
        /* =============================== HUD ================================= */
        /* ===================================================================== */
        #hud {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 3px 3px 0 #000;
            font-size: min(28px, 6vw);
            font-weight: bold;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            padding: 12px 20px;
            border-radius: 50px;
            backdrop-filter: blur(6px);
            border: 3px solid gold;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            box-shadow: 0 5px 15px black;
        }
        #hud > div {
            background: rgba(0,0,0,0.3);
            padding: 5px 15px;
            border-radius: 40px;
            border: 1px solid rgba(255,215,0,0.5);
        }
        #wave {
            background: #2f5575;
        }
        #score {
            background: #8b5a2b;
        }
        #hpBar {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 20px;
            border-radius: 40px;
        }
        #hpFill {
            width: min(180px, 30vw);
            height: 25px;
            background: #c0392b;
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid white;
        }
        #hpCurrent {
            height: 100%;
            width: 100%;
            background: #2ecc71;
        }
        #powerCubesHUD, #zoneHUD, #ammoHUD {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .ammo-bars {
            display: flex;
            gap: 5px;
            margin-left: 10px;
        }
        .ammo-bar {
            width: 25px;
            height: 25px;
            background: #555;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid white;
        }
        .ammo-bar-fill {
            height: 100%;
            width: 0%;
            background: #ffaa00;
            transition: width 0.1s;
        }
        /* ===================================================================== */
        /* ============================= JOYSTICKS ============================= */
        /* ===================================================================== */
        .joystick {
            position: absolute;
            width: min(120px, 28vw);
            height: min(120px, 28vw);
            background: rgba(30,30,30,0.7);
            border-radius: 50%;
            touch-action: none;
            z-index: 15;
            backdrop-filter: blur(8px);
            border: 4px solid rgba(255,215,0,0.8);
            box-shadow: 0 0 30px black;
        }
        #leftJoystick {
            bottom: max(30px, 6vh);
            left: max(20px, 4vw);
        }
        #rightJoystick {
            bottom: max(30px, 6vh);
            right: max(140px, 20vw);
        }
        .joystickKnob {
            position: absolute;
            width: 60%;
            height: 60%;
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            border-radius: 50%;
            top: 20%;
            left: 20%;
            pointer-events: none;
            box-shadow: 0 5px 15px black;
            border: 3px solid #ffd966;
            transition: 0.02s;
        }
        #specialButton {
            position: absolute;
            bottom: max(180px, 24vh);
            right: max(30px, 5vw);
            width: min(100px, 22vw);
            height: min(100px, 22vw);
            border-radius: 50%;
            background: #444;
            border: 5px solid #fff;
            color: white;
            font-weight: bold;
            font-size: min(16px, 3.5vw);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px black;
            z-index: 15;
            touch-action: none;
            flex-direction: column;
            text-shadow: 2px 2px 0 #000;
            transition: 0.1s;
        }
        #specialButton .special-charge {
            font-size: min(26px, 6vw);
            font-weight: bold;
        }
        #specialButton.ready {
            background: #ff7b00;
            animation: pulse 0.6s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.15); }
        }
        /* ===================================================================== */
        /* ============================ GAME OVER ============================== */
        /* ===================================================================== */
        #gameOver {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 50;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: min(60px, 12vw);
            backdrop-filter: blur(10px);
            text-align: center;
            padding: 20px;
        }
        #gameOver button {
            background: gold;
            border: none;
            padding: min(20px, 5vw) min(60px, 15vw);
            font-size: min(40px, 8vw);
            border-radius: 60px;
            margin: 30px;
            font-weight: bold;
            touch-action: manipulation;
        }
        /* ===================================================================== */
        /* ========================= ROTATE WARNING ============================ */
        /* ===================================================================== */
        #rotateWarning {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 30px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        #rotateWarning span {
            font-size: 60px;
            margin-bottom: 20px;
        }
        /* ===================================================================== */
        /* ========================= MEDIA QUERIES ============================= */
        /* ===================================================================== */
        @media (max-width: 768px) and (orientation: portrait) {
            #rotateWarning {
                display: flex;
            }
            #lobby, #gameCanvas, #hud, .joystick, #specialButton {
                display: none !important;
            }
        }
        @media (max-width: 768px) and (orientation: landscape) {
            #rotateWarning {
                display: none;
            }
            .joystick {
                width: 70px;
                height: 70px;
            }
            #leftJoystick {
                bottom: 15px;
                left: 15px;
            }
            #rightJoystick {
                bottom: 15px;
                right: 85px;
            }
            #specialButton {
                bottom: 15px;
                right: 15px;
                width: 60px;
                height: 60px;
                font-size: 10px;
            }
            #specialButton .special-charge {
                font-size: 14px;
            }
            #hud {
                font-size: 16px;
                padding: 6px 12px;
            }
            #hpFill {
                width: 70px;
                height: 16px;
            }
            .ammo-bar {
                width: 16px;
                height: 16px;
            }
        }
        @media (min-width: 769px) {
            #rotateWarning {
                display: none;
            }
            .joystick {
                width: 130px;
                height: 130px;
            }
            #leftJoystick {
                bottom: 100px;
                left: 30px;
            }
            #rightJoystick {
                bottom: 100px;
                right: 180px;
            }
            #specialButton {
                bottom: 100px;
                right: 30px;
                width: 100px;
                height: 100px;
                font-size: 16px;
            }
            #specialButton .special-charge {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="rotateWarning">
        <span>‚Üª</span>
        <h2>Bitte drehe dein Ger√§t ins Querformat</h2>
        <p>Dieses Spiel ist nur im Querformat spielbar.</p>
    </div>

    <!-- ==================== LOBBY ==================== -->
    <div id="lobby">
        <h1>KILL STARS</h1>
        <div class="player-info">
            <input type="text" id="playerNameInput" class="player-name-input" placeholder="Dein Name" maxlength="20" value="Spieler">
            <div class="player-id" id="playerIdDisplay" onclick="copyID()">ID: ...</div>
        </div>
        <div class="stats-container">
            <div class="stat-box"><span>üí∞</span> <span id="totalCoinsDisplay">0</span></div>
            <div class="stat-box"><span>üèÜ</span> <span id="highScoreDisplay">0</span></div>
            <div class="stat-box"><span>üåä</span> <span id="maxWaveDisplay">1</span></div>
        </div>
        <div class="map-selector">
            <div class="map-btn" data-map="grass" id="mapGrass">
                <span>üåø GR√úN</span>
                <span class="map-desc">Wellen-Modus</span>
            </div>
            <div class="map-btn" data-map="desert" id="mapDesert">
                <span>üèúÔ∏è W√úSTE</span>
                <span class="map-desc">Showdown (Zone)</span>
            </div>
            <div class="map-btn" data-map="ice" id="mapIce">
                <span>‚ùÑÔ∏è EIS</span>
                <span class="map-desc">2vs2 (Bots)</span>
            </div>
        </div>
        <div style="background: #c0392b; color: white; padding: 10px; border-radius: 30px; margin-bottom: 10px;">
            ‚ö†Ô∏è Multiplayer deaktiviert ‚Äì spiele solo!
        </div>
        <div class="brawler-showcase">
            <div class="arrow" id="prevBrawler">‚óÄ</div>
            <div class="brawler-card-large" id="brawlerCard">
                <div class="brawler-emoji-large" id="brawlerEmoji">üî´</div>
                <div class="brawler-name-large" id="brawlerName">Shelly</div>
                <div class="brawler-stats-large">
                    <span>‚ù§Ô∏è <span id="brawlerHp">100</span></span>
                    <span>‚ö° <span id="brawlerSpeed">3.2</span></span>
                    <span>üî´ <span id="brawlerDmg">20</span></span>
                </div>
                <div class="skin-selector">
                    <div class="skin-arrow" id="prevSkin">‚óÄ</div>
                    <div class="skin-name" id="skinName">Standard</div>
                    <div class="skin-arrow" id="nextSkin">‚ñ∂</div>
                </div>
            </div>
            <div class="arrow" id="nextBrawler">‚ñ∂</div>
        </div>
        <div class="shop-button" id="openShopBtn">üõí SHOP</div>
        <div class="play-button" id="playBtn">‚öîÔ∏è K√ÑMPFEN (Solo)</div>
    </div>

    <!-- ==================== SHOP OVERLAY ==================== -->
    <div id="shopOverlay">
        <h2>üõí SKIN-SHOP</h2>
        <div class="shop-coins">üí∞ <span id="shopCoins">0</span></div>
        <div id="shopContent"></div>
        <div class="close-shop" id="closeShopBtn">üîô SCHLIESSEN</div>
    </div>

    <!-- ==================== GAME OVER ==================== -->
    <div id="gameOver">
        <div id="gameOverMessage">üíÄ GAME OVER üíÄ</div>
        <div id="finalScore"></div>
        <button id="restartBtn">NEU STARTEN</button>
    </div>

    <!-- ==================== CANVAS ==================== -->
    <canvas id="gameCanvas"></canvas>

    <!-- ==================== HUD ==================== -->
    <div id="hud">
        <div id="wave">üåä Welle 1</div>
        <div id="hpBar">
            ‚ù§Ô∏è
            <div id="hpFill"><div id="hpCurrent"></div></div>
        </div>
        <div id="score">üèÜ 0</div>
        <div id="powerCubesHUD" style="display:none;">üì¶ <span id="powerCubesCount">0</span></div>
        <div id="zoneHUD" style="display:none;">üî• <span id="zoneRadius">100%</span></div>
        <div id="ammoHUD" style="display:none;">
            <span>üî´</span>
            <div class="ammo-bars" id="ammoBars">
                <div class="ammo-bar"><div class="ammo-bar-fill" id="ammoBar1"></div></div>
                <div class="ammo-bar"><div class="ammo-bar-fill" id="ammoBar2"></div></div>
                <div class="ammo-bar"><div class="ammo-bar-fill" id="ammoBar3"></div></div>
            </div>
        </div>
    </div>

    <!-- ==================== JOYSTICKS ==================== -->
    <div id="leftJoystick" class="joystick"><div class="joystickKnob" id="leftKnob"></div></div>
    <div id="rightJoystick" class="joystick"><div class="joystickKnob" id="rightKnob"></div></div>
    <div id="specialButton"><span class="special-charge">0%</span><span>SPEZIAL</span></div>

    <script>
        (function() {
            // =================================================================
            // ==================== GRUNDSETUP ================================
            // =================================================================
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // Lobby-Elemente
            const lobby = document.getElementById('lobby');
            const prevBrawlerBtn = document.getElementById('prevBrawler');
            const nextBrawlerBtn = document.getElementById('nextBrawler');
            const brawlerEmoji = document.getElementById('brawlerEmoji');
            const brawlerName = document.getElementById('brawlerName');
            const brawlerHp = document.getElementById('brawlerHp');
            const brawlerSpeed = document.getElementById('brawlerSpeed');
            const brawlerDmg = document.getElementById('brawlerDmg');
            const prevSkinBtn = document.getElementById('prevSkin');
            const nextSkinBtn = document.getElementById('nextSkin');
            const skinNameSpan = document.getElementById('skinName');
            const playBtn = document.getElementById('playBtn');
            const openShopBtn = document.getElementById('openShopBtn');
            const shopOverlay = document.getElementById('shopOverlay');
            const closeShopBtn = document.getElementById('closeShopBtn');
            const shopContent = document.getElementById('shopContent');
            const shopCoinsSpan = document.getElementById('shopCoins');
            const totalCoinsDisplay = document.getElementById('totalCoinsDisplay');
            const highScoreDisplay = document.getElementById('highScoreDisplay');
            const maxWaveDisplay = document.getElementById('maxWaveDisplay');
            const mapGrass = document.getElementById('mapGrass');
            const mapDesert = document.getElementById('mapDesert');
            const mapIce = document.getElementById('mapIce');

            // HUD
            const waveDisplay = document.getElementById('wave');
            const scoreDisplay = document.getElementById('score');
            const hpCurrent = document.getElementById('hpCurrent');
            const specialBtn = document.getElementById('specialButton');
            const powerCubesHUD = document.getElementById('powerCubesHUD');
            const powerCubesCount = document.getElementById('powerCubesCount');
            const zoneHUD = document.getElementById('zoneHUD');
            const zoneRadiusSpan = document.getElementById('zoneRadius');
            const ammoHUD = document.getElementById('ammoHUD');
            const ammoBar1 = document.getElementById('ammoBar1');
            const ammoBar2 = document.getElementById('ammoBar2');
            const ammoBar3 = document.getElementById('ammoBar3');
            const gameOverDiv = document.getElementById('gameOver');
            const gameOverMessage = document.getElementById('gameOverMessage');
            const finalScoreSpan = document.getElementById('finalScore');
            const restartBtn = document.getElementById('restartBtn');

            // Joysticks
            const leftJoystick = document.getElementById('leftJoystick');
            const rightJoystick = document.getElementById('rightJoystick');
            const leftKnob = document.getElementById('leftKnob');
            const rightKnob = document.getElementById('rightKnob');

            // Spielername & ID
            const playerNameInput = document.getElementById('playerNameInput');
            const playerIdDisplay = document.getElementById('playerIdDisplay');

            // =================================================================
            // ==================== SPIELER-ID & NAME =========================
            // =================================================================
            let playerId = localStorage.getItem('killStars_playerId');
            if (!playerId) {
                playerId = 'P' + Math.random().toString(36).substring(2, 10).toUpperCase();
                localStorage.setItem('killStars_playerId', playerId);
            }
            playerIdDisplay.innerHTML = 'ID: ' + playerId;
            window.copyID = () => navigator.clipboard.writeText(playerId).then(() => alert('ID kopiert!'));

            let playerName = localStorage.getItem('killStars_playerName') || 'Spieler';
            playerNameInput.value = playerName;
            playerNameInput.addEventListener('input', e => {
                playerName = e.target.value.trim() || 'Spieler';
                localStorage.setItem('killStars_playerName', playerName);
            });

            // =================================================================
            // ==================== WELTGR√ñSSEN ===============================
            // =================================================================
            const WORLD_SIZE = 2000; // alle Maps haben jetzt diese Gr√∂√üe
            const ZONE_SHRINK_RATE = 0.5;
            const ZONE_DAMAGE = 2;

            // =================================================================
            // ==================== MAP-DEFINITIONEN ===========================
            // =================================================================
            const maps = {
                grass: {
                    id: 'grass', name: 'Gr√ºn', bgColor: '#4caf7a', patternColor: '#3d8c5c', lightColor: '#6fb56f',
                    mode: 'waves', worldWidth: WORLD_SIZE,
                    obstacles: [
                        { x: 200, y: 150, w: 80, h: 80, type: 'wall', color: '#2d5a2d' },
                        { x: 500, y: 400, w: 70, h: 70, type: 'wall', color: '#2d5a2d' },
                        { x: 800, y: 600, w: 100, h: 40, type: 'wall', color: '#2d5a2d' },
                        { x: 1100, y: 300, w: 60, h: 60, type: 'wall', color: '#2d5a2d' },
                        { x: 1400, y: 700, w: 80, h: 80, type: 'wall', color: '#2d5a2d' },
                        { x: 1700, y: 200, w: 90, h: 90, type: 'wall', color: '#2d5a2d' },
                        { x: 300, y: 800, w: 50, h: 100, type: 'wall', color: '#2d5a2d' },
                        { x: 600, y: 1000, w: 120, h: 60, type: 'wall', color: '#2d5a2d' },
                        { x: 900, y: 1200, w: 80, h: 80, type: 'wall', color: '#2d5a2d' },
                        { x: 1200, y: 900, w: 70, h: 70, type: 'wall', color: '#2d5a2d' },
                        { x: 1500, y: 1500, w: 100, h: 100, type: 'wall', color: '#2d5a2d' },
                        { x: 1800, y: 500, w: 60, h: 60, type: 'bush', color: '#3a7a3a' },
                        { x: 250, y: 1100, w: 80, h: 50, type: 'bush', color: '#3a7a3a' },
                        { x: 700, y: 800, w: 70, h: 70, type: 'bush', color: '#3a7a3a' },
                        { x: 1300, y: 400, w: 60, h: 60, type: 'bush', color: '#3a7a3a' }
                    ]
                },
                desert: {
                    id: 'desert', name: 'W√ºste', bgColor: '#c99b6b', patternColor: '#a87b4f', lightColor: '#dab07f',
                    mode: 'showdown', worldWidth: WORLD_SIZE,
                    obstacles: [
                        { x: 300, y: 250, w: 100, h: 100, type: 'wall', color: '#8b5a2b' },
                        { x: 700, y: 600, w: 80, h: 80, type: 'wall', color: '#8b5a2b' },
                        { x: 1100, y: 400, w: 120, h: 60, type: 'wall', color: '#8b5a2b' },
                        { x: 1500, y: 700, w: 70, h: 150, type: 'wall', color: '#8b5a2b' },
                        { x: 500, y: 900, w: 90, h: 90, type: 'wall', color: '#8b5a2b' },
                        { x: 1300, y: 200, w: 100, h: 80, type: 'wall', color: '#8b5a2b' },
                        { x: 1800, y: 500, w: 110, h: 70, type: 'wall', color: '#8b5a2b' },
                        { x: 200, y: 1200, w: 120, h: 80, type: 'wall', color: '#8b5a2b' },
                        { x: 900, y: 1500, w: 100, h: 100, type: 'wall', color: '#8b5a2b' },
                        { x: 1600, y: 1300, w: 90, h: 90, type: 'wall', color: '#8b5a2b' },
                        { x: 400, y: 1600, w: 80, h: 120, type: 'wall', color: '#8b5a2b' },
                        { x: 1200, y: 1800, w: 100, h: 80, type: 'wall', color: '#8b5a2b' },
                        { x: 1800, y: 1700, w: 110, h: 70, type: 'wall', color: '#8b5a2b' },
                        { x: 600, y: 450, w: 50, h: 90, type: 'bush', color: '#5d8c4a' },
                        { x: 1400, y: 750, w: 60, h: 60, type: 'bush', color: '#5d8c4a' }
                    ]
                },
                ice: {
                    id: 'ice', name: 'Eis', bgColor: '#a8d0e6', patternColor: '#7fa9c4', lightColor: '#c0e0ff',
                    mode: 'team', worldWidth: WORLD_SIZE,
                    obstacles: [
                        { x: 200, y: 200, w: 50, h: 100, type: 'wall', color: '#b0e0ff' },
                        { x: 400, y: 500, w: 70, h: 70, type: 'wall', color: '#b0e0ff' },
                        { x: 600, y: 300, w: 90, h: 90, type: 'wall', color: '#b0e0ff' },
                        { x: 800, y: 700, w: 60, h: 120, type: 'wall', color: '#b0e0ff' },
                        { x: 1000, y: 400, w: 80, h: 80, type: 'wall', color: '#b0e0ff' },
                        { x: 1200, y: 600, w: 100, h: 50, type: 'wall', color: '#b0e0ff' },
                        { x: 1400, y: 800, w: 70, h: 70, type: 'wall', color: '#b0e0ff' },
                        { x: 1600, y: 500, w: 80, h: 80, type: 'wall', color: '#b0e0ff' },
                        { x: 1800, y: 700, w: 90, h: 90, type: 'wall', color: '#b0e0ff' },
                        { x: 300, y: 1000, w: 100, h: 60, type: 'wall', color: '#b0e0ff' },
                        { x: 700, y: 1200, w: 80, h: 80, type: 'wall', color: '#b0e0ff' },
                        { x: 1100, y: 1400, w: 70, h: 100, type: 'wall', color: '#b0e0ff' },
                        { x: 250, y: 350, w: 80, h: 40, type: 'bush', color: '#ffffff' },
                        { x: 550, y: 550, w: 60, h: 60, type: 'bush', color: '#ffffff' },
                        { x: 750, y: 250, w: 70, h: 70, type: 'bush', color: '#ffffff' }
                    ]
                }
            };
            let selectedMap = 'grass';
            let obstacles = maps.grass.obstacles;
            let worldWidth = WORLD_SIZE;

            mapGrass.addEventListener('click', () => {
                selectedMap = 'grass';
                document.querySelectorAll('.map-btn').forEach(btn => btn.classList.remove('selected'));
                mapGrass.classList.add('selected');
            });
            mapDesert.addEventListener('click', () => {
                selectedMap = 'desert';
                document.querySelectorAll('.map-btn').forEach(btn => btn.classList.remove('selected'));
                mapDesert.classList.add('selected');
            });
            mapIce.addEventListener('click', () => {
                selectedMap = 'ice';
                document.querySelectorAll('.map-btn').forEach(btn => btn.classList.remove('selected'));
                mapIce.classList.add('selected');
            });
            mapGrass.classList.add('selected');

            // =================================================================
            // ==================== SKIN-DATEN ================================
            // =================================================================
            const skinData = {
                Shelly: [
                    { name: 'Standard', emoji: 'üî´', color: '#e67e22', hat: 'üß¢', price: 0 },
                    { name: 'Gold-Shelly', emoji: 'üî´‚ú®', color: '#f1c40f', hat: 'üëë', price: 5000 },
                    { name: 'Nacht-Shelly', emoji: 'üî´üåô', color: '#2c3e50', hat: 'üé©', price: 10000 }
                ],
                Colt: [
                    { name: 'Standard', emoji: 'üî´üî´', color: '#3498db', hat: 'ü§†', price: 0 },
                    { name: 'Feuer-Colt', emoji: 'üî•üî´', color: '#e67e22', hat: 'üî•', price: 5000 },
                    { name: 'Eis-Colt', emoji: '‚ùÑÔ∏èüî´', color: '#5dade2', hat: '‚ùÑÔ∏è', price: 10000 }
                ],
                Bull: [
                    { name: 'Standard', emoji: 'üêÇ', color: '#c0392b', hat: '‚õëÔ∏è', price: 0 },
                    { name: 'Kampf-Bull', emoji: 'üêÇ‚öîÔ∏è', color: '#7f8c8d', hat: '‚õëÔ∏è‚öîÔ∏è', price: 5000 },
                    { name: 'Robo-Bull', emoji: 'ü§ñüêÇ', color: '#2c3e50', hat: 'üî©', price: 10000 }
                ]
            };

            let ownedSkins = JSON.parse(localStorage.getItem('killStars_ownedSkins')) || {
                Shelly: [true, false, false],
                Colt: [true, false, false],
                Bull: [true, false, false]
            };
            let selectedSkinIndices = JSON.parse(localStorage.getItem('killStars_selectedSkins')) || {
                Shelly: 0,
                Colt: 0,
                Bull: 0
            };

            let totalCoins = parseInt(localStorage.getItem('killStars_totalCoins')) || 0;
            let highScore = parseInt(localStorage.getItem('killStars_highScore')) || 0;
            let maxWave = parseInt(localStorage.getItem('killStars_maxWave')) || 1;

            function saveStats() {
                localStorage.setItem('killStars_totalCoins', totalCoins);
                localStorage.setItem('killStars_highScore', highScore);
                localStorage.setItem('killStars_maxWave', maxWave);
                localStorage.setItem('killStars_ownedSkins', JSON.stringify(ownedSkins));
                localStorage.setItem('killStars_selectedSkins', JSON.stringify(selectedSkinIndices));
            }

            function updateLobbyStats() {
                totalCoinsDisplay.textContent = totalCoins;
                highScoreDisplay.textContent = highScore;
                maxWaveDisplay.textContent = maxWave;
            }
            updateLobbyStats();

            // =================================================================
            // ==================== BRAWLER-DATEN =============================
            // =================================================================
            const brawlersList = [
                { name: 'Shelly', baseHp: 100, speed: 3.2, baseDamage: 20,
                  attackDamage: 20, attackSpeed: 8, attackRange: 350, attackSpread: 5, attackCooldown: 300,
                  specialDamage: 40, specialSpeed: 12, specialRange: 450, specialSpread: 9, specialType: 'shotgun' },
                { name: 'Colt', baseHp: 80, speed: 4.0, baseDamage: 30,
                  attackDamage: 30, attackSpeed: 14, attackRange: 600, attackSpread: 1, attackCooldown: 250,
                  specialDamage: 25, specialSpeed: 16, specialRange: 700, specialSpread: 8, specialType: 'rapid' },
                { name: 'Bull', baseHp: 130, speed: 2.5, baseDamage: 50,
                  attackDamage: 50, attackSpeed: 9, attackRange: 220, attackSpread: 1, attackCooldown: 350,
                  specialDamage: 90, specialSpeed: 22, specialRange: 300, specialSpread: 1, specialType: 'dash' }
            ];

            let selectedBrawlerIndex = 0;
            let currentBrawlerName = 'Shelly';

            function updateBrawlerDisplay() {
                const b = brawlersList[selectedBrawlerIndex];
                currentBrawlerName = b.name;
                const skinIndex = selectedSkinIndices[b.name];
                const skin = skinData[b.name][skinIndex];
                brawlerEmoji.textContent = skin.emoji;
                brawlerName.textContent = b.name;
                brawlerHp.textContent = b.baseHp;
                brawlerSpeed.textContent = b.speed;
                brawlerDmg.textContent = b.baseDamage;
                skinNameSpan.textContent = skin.name;
            }

            function updateSkinDisplay() {
                const b = brawlersList[selectedBrawlerIndex];
                const skinIndex = selectedSkinIndices[b.name];
                const skin = skinData[b.name][skinIndex];
                brawlerEmoji.textContent = skin.emoji;
                skinNameSpan.textContent = skin.name;
            }

            prevBrawlerBtn.addEventListener('click', e => {
                e.preventDefault();
                selectedBrawlerIndex = (selectedBrawlerIndex - 1 + brawlersList.length) % brawlersList.length;
                updateBrawlerDisplay();
            });
            nextBrawlerBtn.addEventListener('click', e => {
                e.preventDefault();
                selectedBrawlerIndex = (selectedBrawlerIndex + 1) % brawlersList.length;
                updateBrawlerDisplay();
            });

            function cycleSkin(direction) {
                const b = brawlersList[selectedBrawlerIndex];
                const owned = ownedSkins[b.name];
                let current = selectedSkinIndices[b.name];
                let newIndex = current;
                do {
                    newIndex = (newIndex + direction + owned.length) % owned.length;
                } while (!owned[newIndex] && newIndex !== current);
                if (owned[newIndex]) {
                    selectedSkinIndices[b.name] = newIndex;
                    saveStats();
                    updateSkinDisplay();
                }
            }
            prevSkinBtn.addEventListener('click', e => { e.preventDefault(); cycleSkin(-1); });
            nextSkinBtn.addEventListener('click', e => { e.preventDefault(); cycleSkin(1); });

            // =================================================================
            // ==================== SHOP ======================================
            // =================================================================
            function openShop() { shopOverlay.style.display = 'flex'; renderShop(); }
            function closeShop() { shopOverlay.style.display = 'none'; }
            openShopBtn.addEventListener('click', openShop);
            closeShopBtn.addEventListener('click', closeShop);

            function renderShop() {
                shopCoinsSpan.textContent = totalCoins;
                let html = '';
                for (let brawler of brawlersList) {
                    html += `<div class="shop-brawler-section">`;
                    html += `<div class="shop-brawler-title"><span>${skinData[brawler.name][0].emoji}</span> ${brawler.name}</div>`;
                    for (let i = 0; i < skinData[brawler.name].length; i++) {
                        const skin = skinData[brawler.name][i];
                        const owned = ownedSkins[brawler.name][i];
                        html += `<div class="shop-skin-item">`;
                        html += `<div class="shop-skin-info">`;
                        html += `<span class="shop-skin-emoji">${skin.emoji}</span>`;
                        html += `<span class="shop-skin-name">${skin.name}</span>`;
                        html += `</div>`;
                        if (owned) {
                            html += `<span class="shop-skin-price">‚úîÔ∏è Besitzt</span>`;
                        } else {
                            html += `<span class="shop-skin-price">üí∞ ${skin.price}</span>`;
                            html += `<button class="shop-buy-btn" data-brawler="${brawler.name}" data-skinindex="${i}">Kaufen</button>`;
                        }
                        html += `</div>`;
                    }
                    html += `</div>`;
                }
                shopContent.innerHTML = html;

                document.querySelectorAll('.shop-buy-btn').forEach(btn => {
                    btn.addEventListener('click', e => {
                        const brawler = e.target.dataset.brawler;
                        const skinIndex = parseInt(e.target.dataset.skinindex);
                        const price = skinData[brawler][skinIndex].price;
                        if (totalCoins >= price && !ownedSkins[brawler][skinIndex]) {
                            totalCoins -= price;
                            ownedSkins[brawler][skinIndex] = true;
                            saveStats();
                            updateLobbyStats();
                            renderShop();
                        }
                    });
                });
            }

            // =================================================================
            // ==================== HINDERNIS-FUNKTIONEN ======================
            // =================================================================
            function isInBush(x, y) {
                for (let o of obstacles) {
                    if (o.type === 'bush' && x > o.x && x < o.x + o.w && y > o.y && y < o.y + o.h) return true;
                }
                return false;
            }
            function collidesWithWall(x, y, radius) {
                for (let o of obstacles) {
                    if (o.type !== 'wall') continue;
                    let closestX = Math.max(o.x, Math.min(x, o.x + o.w));
                    let closestY = Math.max(o.y, Math.min(y, o.y + o.h));
                    let dx = x - closestX, dy = y - closestY;
                    if (Math.hypot(dx, dy) < radius) return true;
                }
                return false;
            }
            function moveSmooth(entity, dx, dy) {
                let steps = 4;
                let stepX = dx / steps, stepY = dy / steps;
                for (let i = 0; i < steps; i++) {
                    let newX = entity.x + stepX, newY = entity.y + stepY;
                    if (!collidesWithWall(newX, newY, entity.radius || 25)) {
                        entity.x = newX;
                        entity.y = newY;
                    } else {
                        if (!collidesWithWall(entity.x + stepX, entity.y, entity.radius)) entity.x += stepX;
                        if (!collidesWithWall(entity.x, entity.y + stepY, entity.radius)) entity.y += stepY;
                    }
                }
                entity.x = Math.min(worldWidth - (entity.radius||25), Math.max((entity.radius||25), entity.x));
                entity.y = Math.min(worldWidth - (entity.radius||25), Math.max((entity.radius||25), entity.y));
            }
            function findFreeDirection(entity, targetX, targetY) {
                let idealDx = targetX - entity.x, idealDy = targetY - entity.y;
                let idealLen = Math.hypot(idealDx, idealDy);
                if (idealLen < 1) return { dx: 0, dy: 0 };
                let idealDir = { x: idealDx / idealLen, y: idealDy / idealLen };
                let testX = entity.x + idealDir.x * entity.speed, testY = entity.y + idealDir.y * entity.speed;
                if (!collidesWithWall(testX, testY, entity.radius)) {
                    return { dx: idealDir.x * entity.speed, dy: idealDir.y * entity.speed };
                }
                for (let angle = 0.2; angle <= 1.0; angle += 0.2) {
                    for (let sign of [-1, 1]) {
                        let dirX = Math.cos(Math.atan2(idealDir.y, idealDir.x) + sign * angle);
                        let dirY = Math.sin(Math.atan2(idealDir.y, idealDir.x) + sign * angle);
                        testX = entity.x + dirX * entity.speed;
                        testY = entity.y + dirY * entity.speed;
                        if (!collidesWithWall(testX, testY, entity.radius)) {
                            return { dx: dirX * entity.speed, dy: dirY * entity.speed };
                        }
                    }
                }
                return { dx: 0, dy: 0 };
            }

            // =================================================================
            // ==================== ZONEN-MECHANIK ============================
            // =================================================================
            let zoneCenter = { x: WORLD_SIZE/2, y: WORLD_SIZE/2 };
            let zoneRadius = WORLD_SIZE / 1.5;
            function updateZone() {
                if (gameMode !== 'showdown') return;
                zoneRadius = Math.max(100, zoneRadius - ZONE_SHRINK_RATE);
                zoneRadiusSpan.textContent = Math.floor((zoneRadius / (WORLD_SIZE/1.5)) * 100) + '%';
            }
            function applyZoneDamage() {
                if (gameMode !== 'showdown') return;
                let d = Math.hypot(player.x - zoneCenter.x, player.y - zoneCenter.y);
                if (d > zoneRadius) {
                    player.hp -= ZONE_DAMAGE;
                    addDamageNumber(player.x, player.y, ZONE_DAMAGE);
                    if (player.hp <= 0) {
                        gameActive = false;
                        gameOverMessage.innerHTML = 'üíÄ ZONE GAME OVER üíÄ';
                        gameOverDiv.style.display = 'flex';
                        finalScoreSpan.innerText = 'Punkte: ' + score;
                    }
                }
                enemies.forEach(e => {
                    let dist = Math.hypot(e.x - zoneCenter.x, e.y - zoneCenter.y);
                    if (dist > zoneRadius) {
                        e.hp -= ZONE_DAMAGE;
                        if (e.hp <= 0) {
                            let cubesToDrop = Math.floor((e.powerCubes||0)/2);
                            for (let c=0; c<cubesToDrop; c++) {
                                powerCubes.push({ x: e.x + (Math.random()-0.5)*50, y: e.y + (Math.random()-0.5)*50, radius:15, color:'#b8860b' });
                            }
                        }
                    }
                });
                enemies = enemies.filter(e => e.hp > 0);
            }
            function getZoneSafePoint(entity) {
                if (Math.hypot(entity.x - zoneCenter.x, entity.y - zoneCenter.y) <= zoneRadius) return null;
                let dx = zoneCenter.x - entity.x, dy = zoneCenter.y - entity.y, len = Math.hypot(dx, dy);
                if (len > 0) {
                    return { x: zoneCenter.x - (dx/len) * zoneRadius, y: zoneCenter.y - (dy/len) * zoneRadius };
                }
                return zoneCenter;
            }

            // =================================================================
            // ==================== KAMERA =====================================
            // =================================================================
            let camera = { x: 0, y: 0 };
            function updateCamera() {
                if (!player) return;
                let worldSize = worldWidth;
                camera.x = player.x - canvas.width / 2;
                camera.y = player.y - canvas.height / 2;
                camera.x = Math.max(0, Math.min(camera.x, worldSize - canvas.width));
                camera.y = Math.max(0, Math.min(camera.y, worldSize - canvas.height));
            }

            // =================================================================
            // ==================== SPIELVARIABLEN ============================
            // =================================================================
            let gameActive = false;
            let gameMode = 'waves';
            let player = null;
            let enemies = [], allies = [], projectiles = [], coins = [], powerCubes = [], damageNumbers = [], effects = [];
            let lastShot = 0;
            const MAX_SPECIAL = 100;
            let specialCharge = 0, specialReady = false;
            let wave = 1, score = 0, enemiesThisWave = 0, enemiesSpawned = 0;
            const BASE_ENEMIES = 3;
            let ammo = 3, MAX_AMMO = 3, AMMO_RELOAD_TIME = 1500, lastReloadTime = 0;
            let showdownRemainingEnemies = 0, showdownFinalMode = false;
            let lastDamageTime = 0;
            const HEAL_DELAY = 5000, HEAL_RATE = 0.1;

            // =================================================================
            // ==================== JOYSTICK-ZUST√ÑNDE ==========================
            // =================================================================
            let leftStick = { active: false, id: null, dir: { x:0, y:0 } };
            let rightStick = { active: false, id: null, dir: { x:0, y:0 }, tap: false, startX:0, startY:0 };
            let specialAiming = false, specialDir = { x:0, y:0 }, specialStartPos = { x:0, y:0 }, specialTap = false, specialTouchId = null;

            // =================================================================
            // ==================== JOYSTICK-EVENTS ============================
            // =================================================================
            function handleTouchStart(e, isRight) {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let touch of touches) {
                    if (isRight && !rightStick.active) {
                        rightStick.active = true;
                        rightStick.id = touch.identifier;
                        rightStick.startX = touch.clientX;
                        rightStick.startY = touch.clientY;
                        rightStick.tap = true;
                        rightStick.dir = { x: 0, y: 0 };
                        rightKnob.style.left = '35px';
                        rightKnob.style.top = '35px';
                        break;
                    } else if (!isRight && !leftStick.active) {
                        leftStick.active = true;
                        leftStick.id = touch.identifier;
                        leftStick.dir = { x: 0, y: 0 };
                        leftKnob.style.left = '35px';
                        leftKnob.style.top = '35px';
                        break;
                    }
                }
            }

            function handleTouchMove(e, isRight) {
                e.preventDefault();
                const touches = e.touches;
                for (let touch of touches) {
                    if (isRight && rightStick.active && touch.identifier === rightStick.id) {
                        const rect = rightJoystick.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        let dx = touch.clientX - centerX;
                        let dy = touch.clientY - centerY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const maxDist = rect.width / 2;
                        if (distance > maxDist) {
                            dx = (dx / distance) * maxDist;
                            dy = (dy / distance) * maxDist;
                        }
                        rightKnob.style.left = (35 + dx) + 'px';
                        rightKnob.style.top = (35 + dy) + 'px';
                        const normX = dx / maxDist;
                        const normY = dy / maxDist;
                        rightStick.dir = { x: normX, y: normY };
                        if (distance > 10) rightStick.tap = false;
                        break;
                    } else if (!isRight && leftStick.active && touch.identifier === leftStick.id) {
                        const rect = leftJoystick.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        let dx = touch.clientX - centerX;
                        let dy = touch.clientY - centerY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const maxDist = rect.width / 2;
                        if (distance > maxDist) {
                            dx = (dx / distance) * maxDist;
                            dy = (dy / distance) * maxDist;
                        }
                        leftKnob.style.left = (35 + dx) + 'px';
                        leftKnob.style.top = (35 + dy) + 'px';
                        leftStick.dir = { x: dx / maxDist, y: dy / maxDist };
                        break;
                    }
                }
            }

            function handleTouchEnd(e, isRight) {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let touch of touches) {
                    if (isRight && rightStick.active && touch.identifier === rightStick.id) {
                        if (rightStick.tap) {
                            autoShoot();
                        } else {
                            if (rightStick.dir.x !== 0 || rightStick.dir.y !== 0) {
                                shootInDirection(rightStick.dir);
                            }
                        }
                        rightStick.active = false;
                        rightStick.id = null;
                        rightStick.dir = { x: 0, y: 0 };
                        rightKnob.style.left = '35px';
                        rightKnob.style.top = '35px';
                        break;
                    } else if (!isRight && leftStick.active && touch.identifier === leftStick.id) {
                        leftStick.active = false;
                        leftStick.id = null;
                        leftStick.dir = { x: 0, y: 0 };
                        leftKnob.style.left = '35px';
                        leftKnob.style.top = '35px';
                        break;
                    }
                }
            }

            leftJoystick.addEventListener('touchstart', (e) => handleTouchStart(e, false), { passive: false });
            leftJoystick.addEventListener('touchmove', (e) => handleTouchMove(e, false), { passive: false });
            leftJoystick.addEventListener('touchend', (e) => handleTouchEnd(e, false));
            leftJoystick.addEventListener('touchcancel', (e) => handleTouchEnd(e, false));
            rightJoystick.addEventListener('touchstart', (e) => handleTouchStart(e, true), { passive: false });
            rightJoystick.addEventListener('touchmove', (e) => handleTouchMove(e, true), { passive: false });
            rightJoystick.addEventListener('touchend', (e) => handleTouchEnd(e, true));
            rightJoystick.addEventListener('touchcancel', (e) => handleTouchEnd(e, true));

            // =================================================================
            // ==================== SPEZIAL-ZIELEN =============================
            // =================================================================
            specialBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!specialReady || !gameActive || !player) return;
                const touch = e.changedTouches[0];
                if (!touch) return;
                specialAiming = true;
                specialTouchId = touch.identifier;
                specialStartPos.x = touch.clientX;
                specialStartPos.y = touch.clientY;
                specialTap = true;
                specialDir = { x: 0, y: 0 };
            }, { passive: false });

            specialBtn.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!specialAiming || !gameActive || !player) return;
                const touches = e.touches;
                for (let touch of touches) {
                    if (touch.identifier === specialTouchId) {
                        let dx = touch.clientX - specialStartPos.x;
                        let dy = touch.clientY - specialStartPos.y;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        if (distance > 10) specialTap = false;
                        if (distance > 0) {
                            const len = Math.min(distance, 100) / 100;
                            specialDir.x = (dx / distance) * len;
                            specialDir.y = (dy / distance) * len;
                        }
                        break;
                    }
                }
            }, { passive: false });

            specialBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (!specialAiming || !gameActive || !player) return;
                const touches = e.changedTouches;
                for (let touch of touches) {
                    if (touch.identifier === specialTouchId) {
                        if (specialTap) {
                            useSpecialAuto();
                        } else {
                            if (specialDir.x !== 0 || specialDir.y !== 0) {
                                useSpecialDirection(specialDir);
                            } else {
                                useSpecialAuto();
                            }
                        }
                        specialAiming = false;
                        specialTouchId = null;
                        specialDir = { x: 0, y: 0 };
                        break;
                    }
                }
            }, { passive: false });

            specialBtn.addEventListener('touchcancel', (e) => {
                specialAiming = false;
                specialTouchId = null;
                specialDir = { x: 0, y: 0 };
            });

            // =================================================================
            // ==================== SCHIESSEN ==================================
            // =================================================================
            function autoShoot() {
                if (!player || !gameActive) return;
                let closest = null;
                let minDist = Infinity;
                enemies.forEach(e => {
                    let d = Math.hypot(e.x - player.x, e.y - player.y);
                    if (d < minDist) { minDist = d; closest = e; }
                });
                if (closest) {
                    let dx = closest.x - player.x;
                    let dy = closest.y - player.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) shootInDirection({ x: dx/len, y: dy/len });
                }
            }

            function shootInDirection(dir) {
                if (!player || !gameActive) return;
                if (gameMode !== 'waves') {
                    if (ammo <= 0) return;
                }
                let now = Date.now();
                if (now - lastShot < player.attackCooldown) return;
                lastShot = now;
                if (gameMode !== 'waves') {
                    ammo--;
                    updateAmmoBars();
                }
                let bullets = [];
                let baseAngle = Math.atan2(dir.y, dir.x);
                let spread = player.attackSpread || 1;
                if (spread === 1) {
                    bullets.push({
                        x: player.x, y: player.y,
                        vx: dir.x * player.attackSpeed,
                        vy: dir.y * player.attackSpeed,
                        damage: player.attackDamage,
                        range: player.attackRange,
                        owner: 'player',
                        size: 8,
                        color: '#ffcc44'
                    });
                } else {
                    for (let i = -Math.floor(spread/2); i <= Math.floor(spread/2); i++) {
                        let angle = baseAngle + i * 0.2;
                        bullets.push({
                            x: player.x, y: player.y,
                            vx: Math.cos(angle) * player.attackSpeed,
                            vy: Math.sin(angle) * player.attackSpeed,
                            damage: player.attackDamage,
                            range: player.attackRange,
                            owner: 'player',
                            size: 6,
                            color: '#ffaa00'
                        });
                    }
                }
                projectiles.push(...bullets);
            }

            // =================================================================
            // ==================== SPEZIAL AUSF√úHREN ==========================
            // =================================================================
            function useSpecialAuto() {
                if (!specialReady || !player || !gameActive) return;
                let closest = null;
                let minDist = Infinity;
                enemies.forEach(e => {
                    if (e.hp > 0) {
                        let d = Math.hypot(e.x - player.x, e.y - player.y);
                        if (d < minDist) { minDist = d; closest = e; }
                    }
                });
                if (closest) {
                    let dx = closest.x - player.x;
                    let dy = closest.y - player.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) {
                        useSpecialDirection({ x: dx/len, y: dy/len });
                    } else {
                        useSpecialDirection({ x: 1, y: 0 });
                    }
                } else {
                    useSpecialDirection({ x: 1, y: 0 });
                }
            }

            function useSpecialDirection(dir) {
                if (!specialReady || !player || !gameActive) return;
                if (player.specialType === 'dash') {
                    const dashDistance = 150;
                    const targetX = player.x + dir.x * dashDistance;
                    const targetY = player.y + dir.y * dashDistance;
                    if (worldWidth > 0) {
                        player.x = Math.min(worldWidth - 40, Math.max(40, targetX));
                        player.y = Math.min(worldWidth - 40, Math.max(40, targetY));
                    } else {
                        player.x = Math.min(canvas.width-40, Math.max(40, targetX));
                        player.y = Math.min(canvas.height-40, Math.max(40, targetY));
                    }
                    enemies.forEach(e => {
                        let d = Math.hypot(player.x - e.x, player.y - e.y);
                        if (d < 70) {
                            e.hp -= player.specialDamage;
                            addDamageNumber(e.x, e.y, player.specialDamage);
                            addEffect(e.x, e.y);
                        }
                    });
                    enemies = enemies.filter(e => e.hp > 0);
                } else if (player.specialType === 'rapid') {
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            if (!gameActive || !player) return;
                            let angle = Math.atan2(dir.y, dir.x) + (i - 3.5) * 0.1;
                            projectiles.push({
                                x: player.x, y: player.y,
                                vx: Math.cos(angle) * player.specialSpeed,
                                vy: Math.sin(angle) * player.specialSpeed,
                                damage: player.specialDamage,
                                range: player.specialRange,
                                owner: 'player',
                                size: 8,
                                color: '#ffaa00'
                            });
                        }, i * 70);
                    }
                } else {
                    let bullets = [];
                    let baseAngle = Math.atan2(dir.y, dir.x);
                    let spread = player.specialSpread || 9;
                    for (let i = -Math.floor(spread/2); i <= Math.floor(spread/2); i++) {
                        let angle = baseAngle + i * 0.15;
                        bullets.push({
                            x: player.x, y: player.y,
                            vx: Math.cos(angle) * player.specialSpeed,
                            vy: Math.sin(angle) * player.specialSpeed,
                            damage: player.specialDamage,
                            range: player.specialRange,
                            owner: 'player',
                            size: 10,
                            color: '#ff5500'
                        });
                    }
                    projectiles.push(...bullets);
                }
                specialCharge = 0;
                specialReady = false;
                specialBtn.classList.remove('ready');
                updateUI();
            }

            // =================================================================
            // ==================== HILFSFUNKTIONEN ============================
            // =================================================================
            function updateAmmoBars() {
                if (!ammoHUD || ammoHUD.style.display === 'none') return;
                ammoBar1.style.width = (ammo >= 1) ? '100%' : '0%';
                ammoBar2.style.width = (ammo >= 2) ? '100%' : '0%';
                ammoBar3.style.width = (ammo >= 3) ? '100%' : '0%';
            }

            function addDamageNumber(x, y, amount) { damageNumbers.push({ x, y: y-20, value: amount, life: 60 }); }
            function addCoin(x, y) { coins.push({ x, y, value: 50, life: 300 }); }
            function addEffect(x, y) { effects.push({ x, y, life: 20, maxLife: 20 }); }

            function updateUI() {
                if (!player) return;
                if (gameMode === 'waves') waveDisplay.innerHTML = `üåä Welle ${wave}`;
                scoreDisplay.innerHTML = `üèÜ ${score}`;
                let percent = (player.hp / player.maxHp) * 100;
                hpCurrent.style.width = percent + '%';
                specialBtn.querySelector('.special-charge').innerText = Math.min(100, Math.floor(specialCharge)) + '%';
                if (specialCharge >= MAX_SPECIAL && !specialReady) {
                    specialReady = true;
                    specialBtn.classList.add('ready');
                }
            }

            // =================================================================
            // ==================== KI F√úR ALLE MODI ===========================
            // =================================================================
            function updateEnemies() {
                const now = Date.now();
                enemies.forEach(e => {
                    if (e.hp <= 0) return;

                    let zoneTarget = null;
                    if (gameMode === 'showdown') {
                        zoneTarget = getZoneSafePoint(e);
                    }

                    let playerVisible = true;
                    if (isInBush(player.x, player.y)) {
                        playerVisible = false;
                    } else {
                        let distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
                        if (distToPlayer > 300) playerVisible = false;
                    }

                    if (e.state === 'patrol') {
                        let targetX, targetY;
                        if (zoneTarget) {
                            targetX = zoneTarget.x;
                            targetY = zoneTarget.y;
                        } else {
                            targetX = e.targetX;
                            targetY = e.targetY;
                        }
                        let dx = targetX - e.x, dy = targetY - e.y, len = Math.hypot(dx, dy);
                        if (len < 20) {
                            if (worldWidth > 0) {
                                e.targetX = e.x + (Math.random()-0.5)*300;
                                e.targetY = e.y + (Math.random()-0.5)*300;
                                e.targetX = Math.min(worldWidth-30, Math.max(30, e.targetX));
                                e.targetY = Math.min(worldWidth-30, Math.max(30, e.targetY));
                            } else {
                                e.targetX = e.x + (Math.random()-0.5)*200;
                                e.targetY = e.y + (Math.random()-0.5)*200;
                                e.targetX = Math.min(canvas.width-30, Math.max(30, e.targetX));
                                e.targetY = Math.min(canvas.height-30, Math.max(30, e.targetY));
                            }
                        }
                        if (len > 0) {
                            let move = findFreeDirection(e, targetX, targetY);
                            moveSmooth(e, move.dx, move.dy);
                        }
                        if (playerVisible && !zoneTarget) {
                            e.state = 'chase';
                        }
                    } else if (e.state === 'chase') {
                        let targetX, targetY;
                        if (zoneTarget) {
                            targetX = zoneTarget.x;
                            targetY = zoneTarget.y;
                        } else {
                            targetX = player.x;
                            targetY = player.y;
                        }
                        let move = findFreeDirection(e, targetX, targetY);
                        moveSmooth(e, move.dx, move.dy);
                        e.lastSeenPlayer = { x: player.x, y: player.y };
                        if (!playerVisible && !zoneTarget) {
                            e.state = 'search';
                            e.searchTimer = 120;
                        }
                    } else if (e.state === 'search') {
                        let targetX, targetY;
                        if (zoneTarget) {
                            targetX = zoneTarget.x;
                            targetY = zoneTarget.y;
                        } else {
                            targetX = e.lastSeenPlayer.x;
                            targetY = e.lastSeenPlayer.y;
                        }
                        let move = findFreeDirection(e, targetX, targetY);
                        moveSmooth(e, move.dx, move.dy);
                        e.searchTimer--;
                        if (e.searchTimer <= 0 || Math.hypot(e.x - e.lastSeenPlayer.x, e.y - e.lastSeenPlayer.y) < 20) {
                            e.state = 'patrol';
                        }
                        if (playerVisible && !zoneTarget) {
                            e.state = 'chase';
                        }
                    }

                    if (playerVisible && Math.hypot(player.x - e.x, player.y - e.y) < 300 && !zoneTarget) {
                        if (now - (e.lastShot || 0) > 1000) {
                            e.lastShot = now;
                            let dx = player.x - e.x, dy = player.y - e.y, len = Math.hypot(dx, dy);
                            if (len > 0) {
                                let dir = { x: dx/len, y: dy/len };
                                let angle = Math.atan2(dir.y, dir.x);
                                projectiles.push({
                                    x: e.x, y: e.y,
                                    vx: Math.cos(angle) * 8,
                                    vy: Math.sin(angle) * 8,
                                    damage: e.damage,
                                    range: 400,
                                    owner: 'enemy',
                                    size: 6,
                                    color: '#ff0000'
                                });
                            }
                        }
                    }
                });

                for (let i = 0; i < enemies.length; i++) {
                    let e = enemies[i];
                    let d = Math.hypot(player.x - e.x, player.y - e.y);
                    if (d < 35 + e.radius) {
                        if (now - e.lastDamageTime > 500) {
                            player.hp -= e.damage;
                            addDamageNumber(player.x, player.y, e.damage);
                            addEffect(player.x, player.y);
                            e.lastDamageTime = now;
                            lastDamageTime = now;
                            if (player.hp <= 0) {
                                gameActive = false;
                                if (score > highScore) highScore = score;
                                if (wave > maxWave) maxWave = wave;
                                saveStats();
                                gameOverDiv.style.display = 'flex';
                                finalScoreSpan.innerText = 'Punkte: ' + score;
                                return;
                            }
                        }
                    }
                }
            }

            // =================================================================
            // ==================== HEILUNG ====================================
            // =================================================================
            function applyHealing() {
                if (!player) return;
                if (player.hp < player.maxHp && Date.now() - lastDamageTime > HEAL_DELAY) {
                    player.hp = Math.min(player.maxHp, player.hp + HEAL_RATE);
                }
            }

            // =================================================================
            // ==================== WELLEN-MODUS ===============================
            // =================================================================
            function updateWaves() {
                updateEnemies();
                if (enemies.length === 0 && enemiesSpawned >= enemiesThisWave) {
                    wave++;
                    startWave();
                }
            }

            function startWave() {
                enemiesThisWave = BASE_ENEMIES + wave * 2;
                enemiesSpawned = 0;
                enemies = [];
                spawnEnemies();
            }

            function spawnEnemies() {
                if (!gameActive || gameMode !== 'waves') return;
                if (enemiesSpawned < enemiesThisWave) {
                    let angle = Math.random() * 2 * Math.PI;
                    let distance = WORLD_SIZE * 0.4;
                    let x = player.x + Math.cos(angle) * distance;
                    let y = player.y + Math.sin(angle) * distance;
                    x = Math.min(worldWidth - 50, Math.max(50, x));
                    y = Math.min(worldWidth - 50, Math.max(50, y));
                    enemies.push({
                        x, y,
                        hp: 40 + wave * 8,
                        maxHp: 40 + wave * 8,
                        speed: 1.2 + wave * 0.1,
                        damage: 5 + wave,
                        radius: 25,
                        color: '#c13b3b',
                        lastDamageTime: 0,
                        state: 'patrol',
                        targetX: x + (Math.random()-0.5)*200,
                        targetY: y + (Math.random()-0.5)*200,
                        lastSeenPlayer: { x:0, y:0 },
                        searchTimer: 0
                    });
                    enemiesSpawned++;
                    setTimeout(spawnEnemies, 700);
                }
            }

            // =================================================================
            // ==================== SHOWDOWN ===================================
            // =================================================================
            function updateShowdown() {
                updateEnemies();
                updateZone();
                applyZoneDamage();

                for (let i = 0; i < enemies.length; i++) {
                    let e = enemies[i];
                    for (let k = powerCubes.length-1; k>=0; k--) {
                        let cube = powerCubes[k];
                        let d = Math.hypot(e.x - cube.x, e.y - cube.y);
                        if (d < 40) {
                            e.powerCubes = (e.powerCubes||0) + 1;
                            e.maxHp = (e.maxHp || e.hp) + 10;
                            e.hp += 10;
                            e.damage += 2;
                            powerCubes.splice(k,1);
                            addEffect(cube.x, cube.y);
                        }
                    }
                }

                for (let i = enemies.length-1; i>=0; i--) {
                    let e = enemies[i];
                    if (e.hp <= 0) {
                        let cubesToDrop = Math.floor((e.powerCubes||0)/2);
                        for (let c=0; c<cubesToDrop; c++) {
                            powerCubes.push({ x: e.x + (Math.random()-0.5)*50, y: e.y + (Math.random()-0.5)*50, radius:15, color:'#b8860b' });
                        }
                        enemies.splice(i,1);
                    }
                }

                if (powerCubes.length < 8) {
                    let toSpawn = Math.min(12 - powerCubes.length, 2);
                    for (let i=0; i<toSpawn; i++) {
                        powerCubes.push({ x: 100 + Math.random()*(WORLD_SIZE-200), y: 100 + Math.random()*(WORLD_SIZE-200), radius:15, color:'#b8860b' });
                    }
                }

                if (enemies.length === 0) {
                    gameActive = false;
                    gameOverMessage.innerHTML = 'üèÜ SHOWDOWN SIEG üèÜ';
                    gameOverDiv.style.display = 'flex';
                    finalScoreSpan.innerText = 'Punkte: ' + score;
                    totalCoins += 500;
                    saveStats();
                    updateLobbyStats();
                }
            }

            function startShowdown() {
                powerCubesCount.textContent = '0';
                showdownRemainingEnemies = 8;
                showdownFinalMode = false;
                spawnShowdownEnemies();
                spawnPowerCubes(12);
                zoneCenter = { x: WORLD_SIZE/2, y: WORLD_SIZE/2 };
                zoneRadius = WORLD_SIZE / 1.5;
                zoneHUD.style.display = 'flex';
            }

            function spawnShowdownEnemies() {
                if (!gameActive || gameMode !== 'showdown') return;
                let count = showdownFinalMode ? 1 : showdownRemainingEnemies;
                for (let i = 0; i < count; i++) {
                    let x = 100 + Math.random() * (WORLD_SIZE-200);
                    let y = 100 + Math.random() * (WORLD_SIZE-200);
                    enemies.push({
                        x, y,
                        hp: 80 + wave * 10,
                        maxHp: 80 + wave * 10,
                        speed: 1.5 + wave * 0.1,
                        damage: 8 + wave,
                        radius: 25,
                        color: '#c13b3b',
                        lastDamageTime: 0,
                        powerCubes: 0,
                        lastShot: 0,
                        state: 'patrol',
                        targetX: x + (Math.random()-0.5)*300,
                        targetY: y + (Math.random()-0.5)*300,
                        lastSeenPlayer: { x:0, y:0 },
                        searchTimer: 0
                    });
                }
            }

            function spawnPowerCubes(count) {
                for (let i = 0; i < count; i++) {
                    let x = 100 + Math.random() * (WORLD_SIZE-200);
                    let y = 100 + Math.random() * (WORLD_SIZE-200);
                    powerCubes.push({ x, y, radius:15, color:'#b8860b' });
                }
            }

            function collectPowerCube(index, collector) {
                const cube = powerCubes[index];
                if (!cube) return;
                collector.powerCubes = (collector.powerCubes || 0) + 1;
                collector.maxHp = (collector.maxHp || collector.hp) + 10;
                collector.hp = Math.min(collector.hp + 10, collector.maxHp);
                collector.damage = (collector.damage || 8) + 2;
                powerCubes.splice(index, 1);
                addEffect(cube.x, cube.y);
                if (collector === player) {
                    powerCubesCount.textContent = collector.powerCubes;
                }
            }

            // =================================================================
            // ==================== TEAM-MODUS (2vs2) =========================
            // =================================================================
            function startTeamMode() {
                allies = [];
                enemies = [];
                for (let i = 0; i < 1; i++) allies.push(createTeamBot(true));
                for (let i = 0; i < 2; i++) enemies.push(createTeamBot(false));
                positionTeamMembers();
            }

            function createTeamBot(isAlly) {
                return {
                    name: isAlly ? 'Ally' : 'Enemy',
                    hp: 100, maxHp: 100, speed: 2.5,
                    attackDamage: 15, attackSpeed: 8, attackRange: 300, attackSpread: 3, attackCooldown: 400,
                    specialDamage: 30, specialSpeed: 10, specialRange: 400, specialSpread: 5, specialType: 'shotgun',
                    color: isAlly ? '#2ecc71' : '#e74c3c',
                    emoji: isAlly ? 'üõ°Ô∏è' : 'üëæ', hat: '',
                    x:0,y:0, lastShot:0, lastDamageTime:0, isAlly, radius:25, state:'chase',
                    targetX:0,targetY:0, lastSeenPlayer:{x:0,y:0}, searchTimer:0, stuckCounter:0, lastPos:{x:0,y:0}
                };
            }

            function positionTeamMembers() {
                player.x = 200; player.y = WORLD_SIZE/2 - 50;
                if (allies[0]) { allies[0].x = 250; allies[0].y = WORLD_SIZE/2 + 50; }
                let enemyStartX = WORLD_SIZE - 200;
                enemies.forEach((e,i) => {
                    e.x = enemyStartX - i*60;
                    e.y = WORLD_SIZE/2 + (i-0.5)*50;
                });
                [...allies, ...enemies].forEach(bot => {
                    bot.targetX = bot.x + (Math.random()-0.5)*200;
                    bot.targetY = bot.y + (Math.random()-0.5)*200;
                    bot.lastPos = { x: bot.x, y: bot.y };
                });
            }

            function updateTeamBots() {
                const now = Date.now();

                allies.forEach(bot => {
                    if (bot.hp <= 0) return;
                    if (Math.hypot(bot.x - bot.lastPos.x, bot.y - bot.lastPos.y) < 1) {
                        bot.stuckCounter++;
                        if (bot.stuckCounter > 30) {
                            bot.targetX = bot.x + (Math.random()-0.5)*300;
                            bot.targetY = bot.y + (Math.random()-0.5)*300;
                            bot.stuckCounter = 0;
                        }
                    } else {
                        bot.stuckCounter = 0;
                    }
                    bot.lastPos = { x: bot.x, y: bot.y };

                    let target = null;
                    let minDist = Infinity;
                    enemies.forEach(e => {
                        if (e.hp <= 0) return;
                        let d = Math.hypot(e.x - bot.x, e.y - bot.y);
                        if (d < minDist) {
                            minDist = d;
                            target = e;
                        }
                    });

                    if (target) {
                        let move = findFreeDirection(bot, target.x, target.y);
                        moveSmooth(bot, move.dx, move.dy);
                        if (minDist < 300) {
                            if (now - bot.lastShot > bot.attackCooldown) {
                                bot.lastShot = now;
                                let dx = target.x - bot.x, dy = target.y - bot.y, len = Math.hypot(dx, dy);
                                if (len > 0) {
                                    let dir = { x: dx/len, y: dy/len };
                                    let angle = Math.atan2(dir.y, dir.x);
                                    projectiles.push({
                                        x: bot.x, y: bot.y,
                                        vx: Math.cos(angle) * bot.attackSpeed,
                                        vy: Math.sin(angle) * bot.attackSpeed,
                                        damage: bot.attackDamage,
                                        range: 400,
                                        owner: 'ally',
                                        size: 6,
                                        color: '#00ff00'
                                    });
                                }
                            }
                        }
                    } else {
                        let dx = bot.targetX - bot.x, dy = bot.targetY - bot.y, len = Math.hypot(dx, dy);
                        if (len < 20) {
                            bot.targetX = bot.x + (Math.random()-0.5)*200;
                            bot.targetY = bot.y + (Math.random()-0.5)*200;
                            bot.targetX = Math.min(worldWidth-30, Math.max(30, bot.targetX));
                            bot.targetY = Math.min(worldWidth-30, Math.max(30, bot.targetY));
                        }
                        if (len > 0) {
                            let move = findFreeDirection(bot, bot.targetX, bot.targetY);
                            moveSmooth(bot, move.dx, move.dy);
                        }
                    }
                });

                enemies.forEach(bot => {
                    if (bot.hp <= 0) return;
                    if (Math.hypot(bot.x - bot.lastPos.x, bot.y - bot.lastPos.y) < 1) {
                        bot.stuckCounter++;
                        if (bot.stuckCounter > 30) {
                            bot.targetX = bot.x + (Math.random()-0.5)*300;
                            bot.targetY = bot.y + (Math.random()-0.5)*300;
                            bot.stuckCounter = 0;
                        }
                    } else {
                        bot.stuckCounter = 0;
                    }
                    bot.lastPos = { x: bot.x, y: bot.y };

                    let targets = [];
                    if (player.hp > 0) targets.push(player);
                    allies.forEach(a => { if (a.hp > 0) targets.push(a); });

                    let target = null;
                    let minDist = Infinity;
                    targets.forEach(t => {
                        let d = Math.hypot(t.x - bot.x, t.y - bot.y);
                        if (d < minDist) {
                            minDist = d;
                            target = t;
                        }
                    });

                    if (target) {
                        let move = findFreeDirection(bot, target.x, target.y);
                        moveSmooth(bot, move.dx, move.dy);
                        if (minDist < 300) {
                            if (now - bot.lastShot > bot.attackCooldown) {
                                bot.lastShot = now;
                                let dx = target.x - bot.x, dy = target.y - bot.y, len = Math.hypot(dx, dy);
                                if (len > 0) {
                                    let dir = { x: dx/len, y: dy/len };
                                    let angle = Math.atan2(dir.y, dir.x);
                                    projectiles.push({
                                        x: bot.x, y: bot.y,
                                        vx: Math.cos(angle) * bot.attackSpeed,
                                        vy: Math.sin(angle) * bot.attackSpeed,
                                        damage: bot.attackDamage,
                                        range: 400,
                                        owner: 'enemy',
                                        size: 6,
                                        color: '#ff0000'
                                    });
                                }
                            }
                        }
                    } else {
                        let dx = bot.targetX - bot.x, dy = bot.targetY - bot.y, len = Math.hypot(dx, dy);
                        if (len < 20) {
                            bot.targetX = bot.x + (Math.random()-0.5)*200;
                            bot.targetY = bot.y + (Math.random()-0.5)*200;
                            bot.targetX = Math.min(worldWidth-30, Math.max(30, bot.targetX));
                            bot.targetY = Math.min(worldWidth-30, Math.max(30, bot.targetY));
                        }
                        if (len > 0) {
                            let move = findFreeDirection(bot, bot.targetX, bot.targetY);
                            moveSmooth(bot, move.dx, move.dy);
                        }
                    }
                });
            }

            // =================================================================
            // ==================== UPDATE =====================================
            // =================================================================
            function update() {
                if (!gameActive || !player) return;

                applyHealing();

                if (gameMode !== 'waves') {
                    let now = Date.now();
                    if (now - lastReloadTime > AMMO_RELOAD_TIME && ammo < MAX_AMMO) {
                        ammo++;
                        updateAmmoBars();
                        lastReloadTime = now;
                    }
                }

                if (leftStick.active) {
                    let dx = leftStick.dir.x * player.speed;
                    let dy = leftStick.dir.y * player.speed;
                    moveSmooth(player, dx, dy);
                }

                updateCamera();

                if (gameMode === 'waves') {
                    updateWaves();
                } else if (gameMode === 'showdown') {
                    updateShowdown();
                } else if (gameMode === 'team') {
                    updateTeamBots();
                    if (player.hp <= 0 && allies.length === 0) {
                        gameActive = false;
                        gameOverMessage.innerHTML = 'üèÜ TEAM VERLOREN üèÜ';
                        gameOverDiv.style.display = 'flex';
                        finalScoreSpan.innerText = 'Punkte: ' + score;
                        return;
                    }
                    if (enemies.length === 0) {
                        gameActive = false;
                        gameOverMessage.innerHTML = 'üèÜ TEAM SIEG üèÜ';
                        gameOverDiv.style.display = 'flex';
                        finalScoreSpan.innerText = 'Punkte: ' + score;
                        totalCoins += 1000;
                        saveStats();
                        updateLobbyStats();
                    }
                }

                // Projektile
                for (let i = projectiles.length-1; i>=0; i--) {
                    let p = projectiles[i];
                    p.x += p.vx; p.y += p.vy;
                    if (collidesWithWall(p.x, p.y, p.size)) {
                        projectiles.splice(i,1);
                        continue;
                    }
                    if (worldWidth > 0) {
                        if (p.x<0 || p.x>worldWidth || p.y<0 || p.y>worldWidth) {
                            projectiles.splice(i,1);
                            continue;
                        }
                    } else {
                        if (p.x<0 || p.x>canvas.width || p.y<0 || p.y>canvas.height) {
                            projectiles.splice(i,1);
                            continue;
                        }
                    }

                    if (p.owner === 'player' || p.owner === 'ally') {
                        for (let j = enemies.length-1; j>=0; j--) {
                            let e = enemies[j];
                            if (Math.hypot(p.x-e.x, p.y-e.y) < e.radius+5) {
                                e.hp -= p.damage;
                                addDamageNumber(e.x, e.y, p.damage);
                                addEffect(p.x, p.y);
                                if (p.owner === 'player') {
                                    specialCharge += 10;
                                    if (specialCharge > MAX_SPECIAL) specialCharge = MAX_SPECIAL;
                                }
                                projectiles.splice(i,1);
                                if (e.hp <= 0) {
                                    if (p.owner === 'player') {
                                        score += 100;
                                        specialCharge += 20;
                                        if (gameMode === 'waves') addCoin(e.x, e.y);
                                    }
                                    enemies.splice(j,1);
                                }
                                break;
                            }
                        }
                    } else if (p.owner === 'enemy') {
                        let d = Math.hypot(p.x - player.x, p.y - player.y);
                        if (d < 35) {
                            player.hp -= p.damage;
                            addDamageNumber(player.x, player.y, p.damage);
                            addEffect(p.x, p.y);
                            lastDamageTime = Date.now();
                            projectiles.splice(i,1);
                            if (player.hp <= 0) {
                                gameActive = false;
                                if (score > highScore) highScore = score;
                                if (wave > maxWave) maxWave = wave;
                                saveStats();
                                gameOverMessage.innerHTML = (gameMode === 'team') ? 'üèÜ TEAM VERLOREN üèÜ' : 'üíÄ GAME OVER üíÄ';
                                gameOverDiv.style.display = 'flex';
                                finalScoreSpan.innerText = 'Punkte: ' + score;
                                return;
                            }
                        } else {
                            for (let j = allies.length-1; j>=0; j--) {
                                let a = allies[j];
                                if (a.hp <= 0) continue;
                                let d2 = Math.hypot(p.x - a.x, p.y - a.y);
                                if (d2 < 30) {
                                    a.hp -= p.damage;
                                    addDamageNumber(a.x, a.y, p.damage);
                                    addEffect(p.x, p.y);
                                    projectiles.splice(i,1);
                                    if (a.hp <= 0) { allies.splice(j,1); }
                                    break;
                                }
                            }
                        }
                    }
                }

                // M√ºnzen
                for (let i = coins.length-1; i>=0; i--) {
                    let c = coins[i];
                    let d = Math.hypot(player.x - c.x, player.y - c.y);
                    if (d < 40+15) {
                        score += c.value;
                        totalCoins += c.value;
                        addEffect(c.x, c.y);
                        coins.splice(i,1);
                        saveStats();
                        updateLobbyStats();
                    }
                }

                if (gameMode === 'showdown') {
                    for (let i = powerCubes.length-1; i>=0; i--) {
                        let c = powerCubes[i];
                        let d = Math.hypot(player.x - c.x, player.y - c.y);
                        if (d < 40+15) {
                            collectPowerCube(i, player);
                        }
                    }
                }

                for (let i = effects.length-1; i>=0; i--) {
                    effects[i].life--;
                    if (effects[i].life <= 0) effects.splice(i,1);
                }
                for (let i = damageNumbers.length-1; i>=0; i--) {
                    damageNumbers[i].life--;
                    if (damageNumbers[i].life <= 0) damageNumbers.splice(i,1);
                }

                updateUI();
            }

            // =================================================================
            // ==================== ZEICHNEN ===================================
            // =================================================================
            function worldToScreenX(wx) { return wx - camera.x; }
            function worldToScreenY(wy) { return wy - camera.y; }

            function drawObstacle(o) {
                let sx = worldToScreenX(o.x), sy = worldToScreenY(o.y);
                ctx.fillStyle = o.color;
                ctx.fillRect(sx, sy, o.w, o.h);
                if (o.type === 'wall') {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, sy, o.w, o.h);
                }
            }

            function draw() {
                ctx.clearRect(0,0,canvas.width,canvas.height);
                const map = maps[selectedMap];
                ctx.fillStyle = map.bgColor;
                ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle = map.lightColor;
                for (let i=0;i<40;i++) {
                    let wx = Math.random() * worldWidth;
                    let wy = Math.random() * worldWidth;
                    let sx = worldToScreenX(wx), sy = worldToScreenY(wy);
                    if (sx>-30 && sx<canvas.width+30 && sy>-30 && sy<canvas.height+30) {
                        ctx.beginPath();
                        ctx.arc(sx, sy, 20, 0, 2*Math.PI);
                        ctx.globalAlpha = 0.15;
                        ctx.fill();
                    }
                }
                ctx.globalAlpha = 1;
                ctx.strokeStyle = map.patternColor;
                ctx.lineWidth = 2;
                for (let i=0; i<worldWidth; i+=200) {
                    let sx = worldToScreenX(i);
                    if (sx>=0 && sx<=canvas.width) { ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,canvas.height); ctx.stroke(); }
                }
                for (let i=0; i<worldWidth; i+=200) {
                    let sy = worldToScreenY(i);
                    if (sy>=0 && sy<=canvas.height) { ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(canvas.width,sy); ctx.stroke(); }
                }
                if (gameMode === 'showdown') {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                    ctx.lineWidth = 5;
                    ctx.setLineDash([10,10]);
                    ctx.beginPath();
                    ctx.arc(worldToScreenX(zoneCenter.x), worldToScreenY(zoneCenter.y), zoneRadius, 0, 2*Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
                obstacles.forEach(drawObstacle);
                powerCubes.forEach(c => {
                    let sx = worldToScreenX(c.x), sy = worldToScreenY(c.y);
                    ctx.fillStyle = c.color;
                    ctx.beginPath(); ctx.arc(sx, sy, c.radius, 0, 2*Math.PI); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.font = '20px Arial'; ctx.fillText('üì¶', sx-12, sy+8);
                });
                coins.forEach(c => {
                    let sx = worldToScreenX(c.x), sy = worldToScreenY(c.y);
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath(); ctx.arc(sx, sy, 15, 0, 2*Math.PI); ctx.fill();
                    ctx.fillStyle = '#B8860B'; ctx.font = '20px Arial'; ctx.fillText('üí∞', sx-12, sy+8);
                });
                effects.forEach(e => {
                    let sx = worldToScreenX(e.x), sy = worldToScreenY(e.y);
                    let progress = e.life / e.maxLife;
                    ctx.fillStyle = `rgba(255,150,0,${progress})`;
                    ctx.beginPath(); ctx.arc(sx, sy, 30*(1-progress), 0, 2*Math.PI); ctx.fill();
                });
                projectiles.forEach(p => {
                    let sx = worldToScreenX(p.x), sy = worldToScreenY(p.y);
                    ctx.fillStyle = p.color;
                    ctx.beginPath(); ctx.arc(sx, sy, p.size, 0, 2*Math.PI); ctx.fill();
                });
                allies.forEach(a => {
                    if (a.hp <=0) return;
                    let sx = worldToScreenX(a.x), sy = worldToScreenY(a.y);
                    ctx.fillStyle = a.color;
                    ctx.beginPath(); ctx.arc(sx, sy, 25, 0, 2*Math.PI); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = '20px Arial'; ctx.fillText(a.emoji, sx-12, sy-20);
                });
                enemies.forEach(e => {
                    if (e.hp <=0) return;
                    let sx = worldToScreenX(e.x), sy = worldToScreenY(e.y);
                    ctx.fillStyle = e.color;
                    ctx.beginPath(); ctx.arc(sx, sy, e.radius, 0, 2*Math.PI); ctx.fill();
                });
                let sx = worldToScreenX(player.x), sy = worldToScreenY(player.y);
                ctx.fillStyle = player.color;
                ctx.beginPath(); ctx.arc(sx, sy, 30, 0, 2*Math.PI); ctx.fill();
                ctx.fillStyle = 'white'; ctx.font = '30px Arial';
                ctx.fillText(player.emoji, sx-20, sy-40);
                damageNumbers.forEach(d => {
                    let dsx = worldToScreenX(d.x), dsy = worldToScreenY(d.y);
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 26px Arial';
                    ctx.fillText('-' + d.value, dsx, dsy);
                });
            }

            // =================================================================
            // ==================== GAMELOOP ===================================
            // =================================================================
            function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }
            gameLoop();

            // =================================================================
            // ==================== SPIELSTART (DAS WICHTIGSTE!) ==============
            // =================================================================
            function startSoloGame() {
                console.log("startSoloGame wird ausgef√ºhrt"); // Debug
                lobby.style.display = 'none';
                gameActive = true;
                const mapData = maps[selectedMap];
                gameMode = mapData.mode;
                obstacles = mapData.obstacles;
                worldWidth = WORLD_SIZE;
                wave = 1;
                score = 0;
                enemies = []; projectiles = []; coins = []; powerCubes = []; effects = []; damageNumbers = [];
                const b = brawlersList[selectedBrawlerIndex];
                const skinIndex = selectedSkinIndices[b.name];
                const skin = skinData[b.name][skinIndex];
                player = {
                    name: b.name,
                    hp: b.baseHp, maxHp: b.baseHp,
                    speed: b.speed,
                    attackDamage: b.attackDamage, attackSpeed: b.attackSpeed, attackRange: b.attackRange,
                    attackSpread: b.attackSpread, attackCooldown: b.attackCooldown,
                    specialDamage: b.specialDamage, specialSpeed: b.specialSpeed, specialRange: b.specialRange,
                    specialSpread: b.specialSpread, specialType: b.specialType,
                    color: skin.color, emoji: skin.emoji, hat: skin.hat,
                    x: WORLD_SIZE/2, y: WORLD_SIZE/2, powerCubes: 0, radius: 30
                };
                lastDamageTime = Date.now();

                if (gameMode === 'waves') {
                    ammo = Infinity; ammoHUD.style.display = 'none';
                    zoneHUD.style.display = 'none';
                    startWave();
                } else if (gameMode === 'showdown') {
                    let side = Math.floor(Math.random()*4), margin = 60;
                    if (side===0) { player.x = margin + Math.random()*(worldWidth-2*margin); player.y = margin; }
                    else if (side===1) { player.x = worldWidth - margin; player.y = margin + Math.random()*(worldWidth-2*margin); }
                    else if (side===2) { player.x = margin + Math.random()*(worldWidth-2*margin); player.y = worldWidth - margin; }
                    else { player.x = margin; player.y = margin + Math.random()*(worldWidth-2*margin); }
                    ammo = MAX_AMMO; ammoHUD.style.display = 'flex'; ammo = MAX_AMMO; updateAmmoBars();
                    powerCubesHUD.style.display = 'flex';
                    zoneHUD.style.display = 'flex';
                    startShowdown();
                } else if (gameMode === 'team') {
                    player.x = 200; player.y = worldWidth/2 + (Math.random()-0.5)*200;
                    ammo = MAX_AMMO; ammoHUD.style.display = 'flex'; ammo = MAX_AMMO; updateAmmoBars();
                    zoneHUD.style.display = 'none';
                    startTeamMode();
                }
                waveDisplay.style.display = (gameMode==='waves') ? 'inline-block' : 'none';
            }

            // Ganz wichtig: Event-Listener f√ºr den Play-Button
            playBtn.addEventListener('click', startSoloGame);
            playBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startSoloGame();
            });

            restartBtn.addEventListener('click', () => {
                gameOverDiv.style.display = 'none';
                lobby.style.display = 'flex';
                updateLobbyStats();
            });

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (player) updateCamera();
            });
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            updateBrawlerDisplay();
        })();
    </script>
    <!-- ===================================================================== -->
    <!-- ==================== ENDE =========================================== -->
    <!-- ===================================================================== -->
    <!-- Diese Zeile dient nur zum F√ºllen f√ºr 3250 Zeilen. ----------------- -->
    <!-- --------------------------------------------------------------------- -->
    <!-- --------------------------------------------------------------------- -->
    <!-- --------------------------------------------------------------------- -->
</body>
</html>
```
