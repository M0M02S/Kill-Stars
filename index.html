<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KILL STARS - Mobile Arena</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            margin: 0;
            padding: 0;
        }
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #1a3b2e;
            touch-action: none;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: #4caf7a;
            touch-action: none;
        }
        /* Lobby */
        #lobby {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(145deg, #1e3c2c, #0f2819);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            color: white;
            text-shadow: 4px 4px 0 #00000080;
            backdrop-filter: blur(8px);
            padding: 20px;
        }
        #lobby h1 {
            font-size: min(15vw, 80px);
            margin-bottom: 10px;
            color: #ffe484;
            text-shadow: 5px 5px 0 #b45f06;
            text-align: center;
        }
        .menu-buttons {
            display: flex;
            gap: min(5vw, 30px);
            margin: 40px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .menu-btn {
            background: #f9b81b;
            border: 4px solid #fff;
            border-radius: 60px;
            padding: min(4vw, 20px) min(10vw, 50px);
            font-size: min(8vw, 40px);
            font-weight: bold;
            color: #3d2b1a;
            text-shadow: 2px 2px 0 #fff;
            box-shadow: 0 10px 0 #a05f00, 0 20px 20px black;
            transition: 0.07s ease;
            cursor: pointer;
            touch-action: manipulation;
        }
        .menu-btn:active {
            transform: translateY(8px);
            box-shadow: 0 5px 0 #a05f00, 0 15px 15px black;
        }
        #brawlerSelectScreen {
            background: #2a4a3a;
            border-radius: 40px;
            padding: 20px;
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            max-width: 95%;
            border: 5px solid #ffd966;
            margin-top: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }
        .brawler-card {
            background: #3d5e4a;
            padding: 15px;
            border-radius: 30px;
            width: min(200px, 40vw);
            text-align: center;
            border: 4px solid #aaa;
            transition: 0.2s;
            box-shadow: 0 8px 0 #1a2e22;
        }
        .brawler-card.selected {
            border-color: #ffd966;
            transform: scale(1.05);
            box-shadow: 0 0 30px gold;
        }
        .brawler-emoji {
            font-size: min(80px, 15vw);
            filter: drop-shadow(5px 10px 0 #00000070);
        }
        .brawler-name {
            font-size: min(28px, 6vw);
            font-weight: bold;
        }
        .brawler-stats {
            font-size: min(16px, 4vw);
            background: #1f2e25;
            padding: 8px;
            border-radius: 20px;
            margin: 10px 0;
        }
        .back-btn {
            background: #a55;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 30px;
            margin-top: 30px;
            border: 3px solid white;
        }
        /* HUD */
        #hud {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            color: white;
            text-shadow: 3px 3px 0 #000;
            font-size: min(28px, 6vw);
            font-weight: bold;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 50px;
            backdrop-filter: blur(6px);
            border: 2px solid gold;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        #wave {
            background: #2f5575;
            padding: 8px 20px;
            border-radius: 40px;
        }
        #score {
            background: #8b5a2b;
            padding: 8px 20px;
            border-radius: 40px;
        }
        #hpBar {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 20px;
            border-radius: 40px;
        }
        #hpFill {
            width: min(150px, 30vw);
            height: 20px;
            background: #c0392b;
            border-radius: 20px;
            overflow: hidden;
            border: 2px solid white;
        }
        #hpCurrent {
            height: 100%;
            width: 100%;
            background: #2ecc71;
        }
        /* Joysticks */
        .joystick {
            position: absolute;
            width: min(140px, 30vw);
            height: min(140px, 30vw);
            background: rgba(30,30,30,0.7);
            border-radius: 50%;
            touch-action: none;
            z-index: 15;
            backdrop-filter: blur(8px);
            border: 4px solid rgba(255,215,0,0.8);
            box-shadow: 0 0 30px black;
        }
        #leftJoystick {
            bottom: min(30px, 5vh);
            left: min(30px, 5vw);
        }
        #rightJoystick {
            bottom: min(30px, 5vh);
            right: min(30px, 5vw);
        }
        .joystickKnob {
            position: absolute;
            width: 60%;
            height: 60%;
            background: radial-gradient(circle at 30% 30%, #fff, #ccc);
            border-radius: 50%;
            top: 20%;
            left: 20%;
            pointer-events: none;
            box-shadow: 0 5px 15px black;
            border: 3px solid #ffd966;
            transition: 0.02s;
        }
        #specialButton {
            position: absolute;
            bottom: min(30px, 5vh);
            right: min(30px, 5vw);
            width: min(110px, 25vw);
            height: min(110px, 25vw);
            border-radius: 50%;
            background: #444;
            border: 5px solid #fff;
            color: white;
            font-weight: bold;
            font-size: min(18px, 4vw);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px black;
            z-index: 15;
            touch-action: none;
            flex-direction: column;
            text-shadow: 2px 2px 0 #000;
        }
        #specialButton .special-charge {
            font-size: min(26px, 6vw);
            font-weight: bold;
        }
        #specialButton.ready {
            background: #ff7b00;
            animation: pulse 0.6s infinite alternate;
        }
        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.15); }
        }
        #gameOver {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 50;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: min(60px, 12vw);
            backdrop-filter: blur(10px);
            text-align: center;
            padding: 20px;
        }
        #gameOver button {
            background: gold;
            border: none;
            padding: min(20px, 5vw) min(60px, 15vw);
            font-size: min(40px, 8vw);
            border-radius: 60px;
            margin: 30px;
            font-weight: bold;
            touch-action: manipulation;
        }
        /* Responsive Anpassungen */
        @media (orientation: portrait) {
            #hud {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <h1>KILL STARS</h1>
        <div class="menu-buttons">
            <div class="menu-btn" id="playBtn">‚öîÔ∏è K√ÑMPFEN</div>
            <div class="menu-btn" id="brawlerMenuBtn">ü¶∏ K√ÑMPFER</div>
        </div>
        <div id="brawlerSelectScreen"></div>
        <div class="menu-btn back-btn" id="backToMain" style="display: none;">üîô ZUR√úCK</div>
    </div>

    <div id="gameOver">
        <div>üíÄ GAME OVER üíÄ</div>
        <div id="finalScore"></div>
        <button id="restartBtn">NEU STARTEN</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="hud">
        <div id="wave">üåä Welle 1</div>
        <div id="hpBar">
            ‚ù§Ô∏è
            <div id="hpFill"><div id="hpCurrent"></div></div>
        </div>
        <div id="score">üèÜ 0</div>
    </div>
    <div id="leftJoystick" class="joystick"><div class="joystickKnob" id="leftKnob"></div></div>
    <div id="rightJoystick" class="joystick"><div class="joystickKnob" id="rightKnob"></div></div>
    <div id="specialButton"><span class="special-charge">0%</span><span>SPEZIAL</span></div>

    <script>
        (function() {
            // Canvas und Context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI-Elemente
            const lobby = document.getElementById('lobby');
            const brawlerSelectScreen = document.getElementById('brawlerSelectScreen');
            const backToMain = document.getElementById('backToMain');
            const playBtn = document.getElementById('playBtn');
            const brawlerMenuBtn = document.getElementById('brawlerMenuBtn');
            const gameOverDiv = document.getElementById('gameOver');
            const finalScoreSpan = document.getElementById('finalScore');
            const restartBtn = document.getElementById('restartBtn');
            const waveDisplay = document.getElementById('wave');
            const scoreDisplay = document.getElementById('score');
            const hpCurrent = document.getElementById('hpCurrent');
            const specialBtn = document.getElementById('specialButton');

            // Joysticks
            const leftJoystick = document.getElementById('leftJoystick');
            const rightJoystick = document.getElementById('rightJoystick');
            const leftKnob = document.getElementById('leftKnob');
            const rightKnob = document.getElementById('rightKnob');

            // Spielzustand
            let gameActive = false;
            let player = null;
            let enemies = [];
            let projectiles = [];
            let coins = [];
            let damageNumbers = [];
            let effects = [];
            let lastShot = 0;
            const SHOT_COOLDOWN = 300;
            let specialCharge = 0;
            const MAX_SPECIAL = 100;
            let specialReady = false;
            let wave = 1;
            let score = 0;
            let enemiesThisWave = 0;
            let enemiesSpawned = 0;
            const BASE_ENEMIES = 3;
            let selectedBrawler = 'Shelly';

            // Joystick-Zust√§nde (mit Touch-IDs f√ºr Multi-Touch)
            let leftStick = { active: false, id: null, dir: { x: 0, y: 0 } };
            let rightStick = { active: false, id: null, dir: { x: 0, y: 0 }, tap: false, startX: 0, startY: 0 };

            // Brawler-Daten
            const brawlers = {
                Shelly: {
                    name: 'Shelly', color: '#e67e22', colorLight: '#f39c12', speed: 3.2,
                    hp: 100, maxHp: 100, emoji: 'üî´', hat: 'üß¢',
                    attackDamage: 20, attackSpeed: 8, attackRange: 350, attackSpread: 5, attackCooldown: 300,
                    specialDamage: 40, specialSpeed: 12, specialRange: 450, specialSpread: 9,
                },
                Colt: {
                    name: 'Colt', color: '#3498db', colorLight: '#5dade2', speed: 4.0,
                    hp: 80, maxHp: 80, emoji: 'üî´üî´', hat: 'ü§†',
                    attackDamage: 30, attackSpeed: 14, attackRange: 600, attackSpread: 1, attackCooldown: 250,
                    specialDamage: 25, specialSpeed: 16, specialRange: 700, specialSpread: 8,
                },
                Bull: {
                    name: 'Bull', color: '#c0392b', colorLight: '#e74c3c', speed: 2.5,
                    hp: 130, maxHp: 130, emoji: 'üêÇ', hat: '‚õëÔ∏è',
                    attackDamage: 50, attackSpeed: 9, attackRange: 220, attackSpread: 1, attackCooldown: 350,
                    specialDamage: 90, specialSpeed: 22, specialRange: 300, specialSpread: 1,
                }
            };

            // Brawler-Karten erstellen
            function buildBrawlerCards() {
                brawlerSelectScreen.innerHTML = '';
                for (let key in brawlers) {
                    let b = brawlers[key];
                    let card = document.createElement('div');
                    card.className = 'brawler-card' + (selectedBrawler === key ? ' selected' : '');
                    card.setAttribute('data-brawler', key);
                    card.innerHTML = `
                        <div class="brawler-emoji">${b.emoji}</div>
                        <div class="brawler-name">${b.name}</div>
                        <div class="brawler-stats">‚ù§Ô∏è ${b.maxHp} | ‚ö° ${b.speed}<br>üî´ ${b.attackDamage}</div>
                    `;
                    card.addEventListener('click', () => {
                        document.querySelectorAll('.brawler-card').forEach(c => c.classList.remove('selected'));
                        card.classList.add('selected');
                        selectedBrawler = key;
                    });
                    brawlerSelectScreen.appendChild(card);
                }
            }
            buildBrawlerCards();

            // Men√º-Navigation
            playBtn.addEventListener('click', () => {
                lobby.style.display = 'none';
                startGame();
            });
            brawlerMenuBtn.addEventListener('click', () => {
                brawlerSelectScreen.style.display = 'flex';
                backToMain.style.display = 'inline-block';
                playBtn.style.display = 'none';
                brawlerMenuBtn.style.display = 'none';
            });
            backToMain.addEventListener('click', () => {
                brawlerSelectScreen.style.display = 'none';
                backToMain.style.display = 'none';
                playBtn.style.display = 'inline-block';
                brawlerMenuBtn.style.display = 'inline-block';
            });

            // Spiel starten
            function startGame() {
                let b = brawlers[selectedBrawler];
                player = {
                    ...b,
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    hp: b.maxHp,
                    maxHp: b.maxHp
                };
                gameActive = true;
                wave = 1;
                score = 0;
                specialCharge = 0;
                specialReady = false;
                specialBtn.classList.remove('ready');
                enemies = [];
                projectiles = [];
                coins = [];
                effects = [];
                damageNumbers = [];
                updateUI();
                startWave();
                gameOverDiv.style.display = 'none';
            }

            function startWave() {
                enemiesThisWave = BASE_ENEMIES + wave * 2;
                enemiesSpawned = 0;
                enemies = [];
                spawnEnemies();
            }

            function spawnEnemies() {
                if (!gameActive) return;
                if (enemiesSpawned < enemiesThisWave) {
                    let angle = Math.random() * 2 * Math.PI;
                    let distance = Math.max(canvas.width, canvas.height) * 0.5;
                    let x = player.x + Math.cos(angle) * distance;
                    let y = player.y + Math.sin(angle) * distance;
                    x = Math.min(canvas.width - 50, Math.max(50, x));
                    y = Math.min(canvas.height - 50, Math.max(50, y));
                    enemies.push({
                        x, y,
                        hp: 40 + wave * 8,
                        maxHp: 40 + wave * 8,
                        speed: 1.2 + wave * 0.1,
                        damage: 3 + wave, // Fairer Schaden
                        radius: 25,
                        color: '#c13b3b',
                        eyeColor: '#ff0000'
                    });
                    enemiesSpawned++;
                    setTimeout(spawnEnemies, 700);
                }
            }

            // Joystick-Event-Handler mit Multi-Touch
            function handleTouchStart(e, isRight) {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let touch of touches) {
                    if (isRight && !rightStick.active) {
                        rightStick.active = true;
                        rightStick.id = touch.identifier;
                        rightStick.startX = touch.clientX;
                        rightStick.startY = touch.clientY;
                        rightStick.tap = true;
                        rightStick.dir = { x: 0, y: 0 };
                        rightKnob.style.left = '35px';
                        rightKnob.style.top = '35px';
                        break;
                    } else if (!isRight && !leftStick.active) {
                        leftStick.active = true;
                        leftStick.id = touch.identifier;
                        leftStick.dir = { x: 0, y: 0 };
                        leftKnob.style.left = '35px';
                        leftKnob.style.top = '35px';
                        break;
                    }
                }
            }

            function handleTouchMove(e, isRight) {
                e.preventDefault();
                const touches = e.touches;
                for (let touch of touches) {
                    if (isRight && rightStick.active && touch.identifier === rightStick.id) {
                        const rect = rightJoystick.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        let dx = touch.clientX - centerX;
                        let dy = touch.clientY - centerY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const maxDist = rect.width / 2;
                        if (distance > maxDist) {
                            dx = (dx / distance) * maxDist;
                            dy = (dy / distance) * maxDist;
                        }
                        rightKnob.style.left = (35 + dx) + 'px';
                        rightKnob.style.top = (35 + dy) + 'px';
                        const normX = dx / maxDist;
                        const normY = dy / maxDist;
                        rightStick.dir = { x: normX, y: normY };
                        if (distance > 10) rightStick.tap = false;
                        break;
                    } else if (!isRight && leftStick.active && touch.identifier === leftStick.id) {
                        const rect = leftJoystick.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        let dx = touch.clientX - centerX;
                        let dy = touch.clientY - centerY;
                        const distance = Math.sqrt(dx*dx + dy*dy);
                        const maxDist = rect.width / 2;
                        if (distance > maxDist) {
                            dx = (dx / distance) * maxDist;
                            dy = (dy / distance) * maxDist;
                        }
                        leftKnob.style.left = (35 + dx) + 'px';
                        leftKnob.style.top = (35 + dy) + 'px';
                        leftStick.dir = { x: dx / maxDist, y: dy / maxDist };
                        break;
                    }
                }
            }

            function handleTouchEnd(e, isRight) {
                e.preventDefault();
                const touches = e.changedTouches;
                for (let touch of touches) {
                    if (isRight && rightStick.active && touch.identifier === rightStick.id) {
                        if (rightStick.tap) {
                            autoShoot();
                        } else {
                            if (rightStick.dir.x !== 0 || rightStick.dir.y !== 0) {
                                shootInDirection(rightStick.dir);
                            }
                        }
                        rightStick.active = false;
                        rightStick.id = null;
                        rightStick.dir = { x: 0, y: 0 };
                        rightKnob.style.left = '35px';
                        rightKnob.style.top = '35px';
                        break;
                    } else if (!isRight && leftStick.active && touch.identifier === leftStick.id) {
                        leftStick.active = false;
                        leftStick.id = null;
                        leftStick.dir = { x: 0, y: 0 };
                        leftKnob.style.left = '35px';
                        leftKnob.style.top = '35px';
                        break;
                    }
                }
            }

            // Event-Listener f√ºr Joysticks
            leftJoystick.addEventListener('touchstart', (e) => handleTouchStart(e, false), { passive: false });
            leftJoystick.addEventListener('touchmove', (e) => handleTouchMove(e, false), { passive: false });
            leftJoystick.addEventListener('touchend', (e) => handleTouchEnd(e, false));
            leftJoystick.addEventListener('touchcancel', (e) => handleTouchEnd(e, false));

            rightJoystick.addEventListener('touchstart', (e) => handleTouchStart(e, true), { passive: false });
            rightJoystick.addEventListener('touchmove', (e) => handleTouchMove(e, true), { passive: false });
            rightJoystick.addEventListener('touchend', (e) => handleTouchEnd(e, true));
            rightJoystick.addEventListener('touchcancel', (e) => handleTouchEnd(e, true));

            // Schie√üfunktionen
            function autoShoot() {
                if (!player || !gameActive) return;
                let closest = null;
                let minDist = Infinity;
                enemies.forEach(e => {
                    let d = Math.hypot(e.x - player.x, e.y - player.y);
                    if (d < minDist) {
                        minDist = d;
                        closest = e;
                    }
                });
                if (closest) {
                    let dx = closest.x - player.x;
                    let dy = closest.y - player.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) {
                        shootInDirection({ x: dx / len, y: dy / len });
                    }
                }
            }

            function shootInDirection(dir) {
                if (!player || !gameActive) return;
                let now = Date.now();
                if (now - lastShot < player.attackCooldown) return;
                lastShot = now;

                let bullets = [];
                let baseAngle = Math.atan2(dir.y, dir.x);
                let spread = player.attackSpread || 1;
                if (spread === 1) {
                    bullets.push({
                        x: player.x, y: player.y,
                        vx: dir.x * player.attackSpeed,
                        vy: dir.y * player.attackSpeed,
                        damage: player.attackDamage,
                        range: player.attackRange,
                        owner: 'player',
                        size: 8,
                        color: '#ffcc44'
                    });
                } else {
                    for (let i = -Math.floor(spread/2); i <= Math.floor(spread/2); i++) {
                        let angle = baseAngle + i * 0.2;
                        bullets.push({
                            x: player.x, y: player.y,
                            vx: Math.cos(angle) * player.attackSpeed,
                            vy: Math.sin(angle) * player.attackSpeed,
                            damage: player.attackDamage,
                            range: player.attackRange,
                            owner: 'player',
                            size: 6,
                            color: '#ffaa00'
                        });
                    }
                }
                projectiles.push(...bullets);
            }

            // Spezial
            function useSpecial() {
                if (!specialReady || !player || !gameActive) return;
                let dir;
                if (rightStick.active && (rightStick.dir.x !== 0 || rightStick.dir.y !== 0)) {
                    dir = rightStick.dir;
                } else {
                    let closest = null;
                    let minDist = Infinity;
                    enemies.forEach(e => {
                        let d = Math.hypot(e.x - player.x, e.y - player.y);
                        if (d < minDist) {
                            minDist = d;
                            closest = e;
                        }
                    });
                    if (closest) {
                        let dx = closest.x - player.x;
                        let dy = closest.y - player.y;
                        let len = Math.hypot(dx, dy);
                        dir = { x: dx / len, y: dy / len };
                    } else {
                        dir = { x: 0, y: 1 };
                    }
                }
                let bullets = [];
                let baseAngle = Math.atan2(dir.y, dir.x);
                let spread = player.specialSpread || 5;
                for (let i = -Math.floor(spread/2); i <= Math.floor(spread/2); i++) {
                    let angle = baseAngle + i * 0.15;
                    bullets.push({
                        x: player.x, y: player.y,
                        vx: Math.cos(angle) * player.specialSpeed,
                        vy: Math.sin(angle) * player.specialSpeed,
                        damage: player.specialDamage,
                        range: player.specialRange,
                        owner: 'player',
                        size: 12,
                        color: '#ff5500'
                    });
                }
                projectiles.push(...bullets);
                specialCharge = 0;
                specialReady = false;
                specialBtn.classList.remove('ready');
                updateUI();
            }
            specialBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                useSpecial();
            });

            // Hilfsfunktionen
            function addDamageNumber(x, y, amount) {
                damageNumbers.push({ x, y: y-20, value: amount, life: 60 });
            }
            function addCoin(x, y) {
                coins.push({ x, y, value: 50, life: 300 });
            }
            function addEffect(x, y) {
                effects.push({ x, y, life: 20, maxLife: 20 });
            }

            // UI aktualisieren
            function updateUI() {
                if (!player) return;
                waveDisplay.innerHTML = `üåä Welle ${wave}`;
                scoreDisplay.innerHTML = `üèÜ ${score}`;
                let percent = (player.hp / player.maxHp) * 100;
                hpCurrent.style.width = percent + '%';
                specialBtn.querySelector('.special-charge').innerText = Math.min(100, Math.floor(specialCharge)) + '%';
                if (specialCharge >= MAX_SPECIAL && !specialReady) {
                    specialReady = true;
                    specialBtn.classList.add('ready');
                }
            }

            // Update-Loop
            function update() {
                if (!gameActive || !player) return;

                // Bewegung (linker Stick)
                if (leftStick.active) {
                    player.x += leftStick.dir.x * player.speed;
                    player.y += leftStick.dir.y * player.speed;
                    player.x = Math.min(canvas.width - 40, Math.max(40, player.x));
                    player.y = Math.min(canvas.height - 40, Math.max(40, player.y));
                }

                // Gegner bewegen
                enemies.forEach(e => {
                    let dx = player.x - e.x;
                    let dy = player.y - e.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) {
                        e.vx = (dx / len) * e.speed;
                        e.vy = (dy / len) * e.speed;
                    }
                    e.x += e.vx;
                    e.y += e.vy;
                    e.x = Math.min(canvas.width - 30, Math.max(30, e.x));
                    e.y = Math.min(canvas.height - 30, Math.max(30, e.y));
                });

                // Projektile
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    let p = projectiles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height) {
                        projectiles.splice(i, 1);
                        continue;
                    }
                    let dist = Math.hypot(p.x - player.x, p.y - player.y);
                    if (dist > p.range) {
                        projectiles.splice(i, 1);
                        continue;
                    }
                    if (p.owner === 'player') {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let e = enemies[j];
                            let d = Math.hypot(p.x - e.x, p.y - e.y);
                            if (d < e.radius + 5) {
                                e.hp -= p.damage;
                                addDamageNumber(e.x, e.y, p.damage);
                                addEffect(p.x, p.y);
                                specialCharge += 10;
                                if (specialCharge > MAX_SPECIAL) specialCharge = MAX_SPECIAL;
                                projectiles.splice(i, 1);
                                if (e.hp <= 0) {
                                    score += 100;
                                    specialCharge += 20;
                                    if (specialCharge > MAX_SPECIAL) specialCharge = MAX_SPECIAL;
                                    addCoin(e.x, e.y);
                                    enemies.splice(j, 1);
                                }
                                break;
                            }
                        }
                    }
                }

                // Gegner-Schaden am Spieler
                for (let i = 0; i < enemies.length; i++) {
                    let e = enemies[i];
                    let d = Math.hypot(player.x - e.x, player.y - e.y);
                    if (d < 35 + e.radius) {
                        player.hp -= e.damage;
                        addDamageNumber(player.x, player.y, e.damage);
                        addEffect(player.x, player.y);
                        if (player.hp <= 0) {
                            gameActive = false;
                            gameOverDiv.style.display = 'flex';
                            finalScoreSpan.innerText = 'Punkte: ' + score;
                            return;
                        }
                    }
                }

                // M√ºnzen einsammeln
                for (let i = coins.length - 1; i >= 0; i--) {
                    let c = coins[i];
                    let d = Math.hypot(player.x - c.x, player.y - c.y);
                    if (d < 40 + 15) {
                        score += c.value;
                        addEffect(c.x, c.y);
                        coins.splice(i, 1);
                    }
                }

                // N√§chste Welle
                if (enemies.length === 0 && enemiesSpawned >= enemiesThisWave) {
                    wave++;
                    startWave();
                }

                // Lebensdauer von Effekten und M√ºnzen
                for (let i = effects.length - 1; i >= 0; i--) {
                    effects[i].life--;
                    if (effects[i].life <= 0) effects.splice(i, 1);
                }
                for (let i = coins.length - 1; i >= 0; i--) {
                    coins[i].life--;
                    if (coins[i].life <= 0) coins.splice(i, 1);
                }
                for (let i = damageNumbers.length - 1; i >= 0; i--) {
                    damageNumbers[i].life--;
                    if (damageNumbers[i].life <= 0) damageNumbers.splice(i, 1);
                }

                updateUI();
            }

            // Zeichnen
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Hintergrund
                ctx.fillStyle = '#5aa45a';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                // Gras-Muster
                ctx.fillStyle = '#6fb56f';
                for (let i = 0; i < 30; i++) {
                    ctx.beginPath();
                    ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, 20, 0, 2*Math.PI);
                    ctx.globalAlpha = 0.15;
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#3d8c5c';
                ctx.lineWidth = 2;
                for (let i = 0; i < canvas.width; i += 70) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, canvas.height);
                    ctx.strokeStyle = '#3d8c5c';
                    ctx.stroke();
                }
                for (let i = 0; i < canvas.height; i += 70) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(canvas.width, i);
                    ctx.stroke();
                }

                if (!gameActive || !player) return;

                // Zielhilfe
                if (rightStick.active && (rightStick.dir.x !== 0 || rightStick.dir.y !== 0)) {
                    let endX = player.x + rightStick.dir.x * 150;
                    let endY = player.y + rightStick.dir.y * 150;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                    ctx.lineWidth = 6;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(endX, endY, 15, 0, 2*Math.PI);
                    ctx.fillStyle = 'rgba(255,0,0,0.7)';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Effekte (Explosionen)
                effects.forEach(e => {
                    let progress = e.life / e.maxLife;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 30 * (1 - progress), 0, 2*Math.PI);
                    ctx.fillStyle = `rgba(255, 150, 0, ${progress})`;
                    ctx.fill();
                });

                // M√ºnzen
                coins.forEach(c => {
                    ctx.save();
                    ctx.shadowColor = 'gold';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, 15, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#B8860B';
                    ctx.font = '20px Arial';
                    ctx.fillText('üí∞', c.x-12, c.y+8);
                    ctx.restore();
                });

                // Projektile
                projectiles.forEach(p => {
                    ctx.save();
                    ctx.shadowColor = 'yellow';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.restore();
                });

                // Gegner
                enemies.forEach(e => {
                    ctx.save();
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 15;
                    // K√∂rper
                    ctx.fillStyle = e.color;
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.radius, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#5a3a2a';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    // Augen
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(e.x-10, e.y-8, 7, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(e.x+10, e.y-8, 7, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(e.x-10, e.y-8, 4, 0, 2*Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(e.x+10, e.y-8, 4, 0, 2*Math.PI);
                    ctx.fill();
                    // Augenbrauen
                    ctx.beginPath();
                    ctx.moveTo(e.x-18, e.y-20);
                    ctx.lineTo(e.x-6, e.y-16);
                    ctx.lineWidth = 4;
                    ctx.strokeStyle = 'black';
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(e.x+18, e.y-20);
                    ctx.lineTo(e.x+6, e.y-16);
                    ctx.stroke();
                    // Lebensbalken
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#c0392b';
                    ctx.fillRect(e.x-25, e.y-40, 50, 6);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(e.x-25, e.y-40, 50 * (e.hp/e.maxHp), 6);
                    ctx.restore();
                });

                // Spieler
                ctx.save();
                ctx.shadowColor = 'white';
                ctx.shadowBlur = 25;
                // K√∂rper
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, 30, 0, 2*Math.PI);
                ctx.fill();
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 5;
                ctx.stroke();
                // Augen
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(player.x-12, player.y-10, 8, 0, 2*Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(player.x+12, player.y-10, 8, 0, 2*Math.PI);
                ctx.fill();
                ctx.fillStyle = '#2c3e50';
                ctx.beginPath();
                ctx.arc(player.x-12, player.y-10, 4, 0, 2*Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(player.x+12, player.y-10, 4, 0, 2*Math.PI);
                ctx.fill();
                // Hut / Accessoire
                ctx.font = '30px Arial';
                ctx.fillStyle = 'white';
                ctx.shadowBlur = 10;
                ctx.fillText(player.hat, player.x-15, player.y-50);
                // Emoji
                ctx.font = '30px Arial';
                ctx.fillText(player.emoji, player.x-20, player.y-80);
                ctx.restore();

                // Schadenszahlen
                ctx.save();
                ctx.font = 'bold 26px Arial';
                ctx.textAlign = 'center';
                damageNumbers.forEach(d => {
                    let alpha = d.life / 60;
                    ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.strokeText('-' + d.value, d.x, d.y);
                    ctx.fillText('-' + d.value, d.x, d.y);
                });
                ctx.restore();
            }

            // GameLoop
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            gameLoop();

            // Neustart
            restartBtn.addEventListener('click', () => {
                gameOverDiv.style.display = 'none';
                lobby.style.display = 'flex';
                brawlerSelectScreen.style.display = 'none';
                backToMain.style.display = 'none';
                playBtn.style.display = 'inline-block';
                brawlerMenuBtn.style.display = 'inline-block';
            });

            // Canvas-Gr√∂√üe anpassen
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                if (player) {
                    player.x = Math.min(canvas.width-40, Math.max(40, player.x));
                    player.y = Math.min(canvas.height-40, Math.max(40, player.y));
                }
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        })();
    </script>
</body>
</html>
